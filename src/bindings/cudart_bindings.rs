/* automatically generated by rust-bindgen */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub const cudaHostAllocDefault: u32 = 0;
pub const cudaHostAllocPortable: u32 = 1;
pub const cudaHostAllocMapped: u32 = 2;
pub const cudaHostAllocWriteCombined: u32 = 4;
pub const cudaHostRegisterDefault: u32 = 0;
pub const cudaHostRegisterPortable: u32 = 1;
pub const cudaHostRegisterMapped: u32 = 2;
pub const cudaHostRegisterIoMemory: u32 = 4;
pub const cudaPeerAccessDefault: u32 = 0;
pub const cudaStreamDefault: u32 = 0;
pub const cudaStreamNonBlocking: u32 = 1;
pub const cudaEventDefault: u32 = 0;
pub const cudaEventBlockingSync: u32 = 1;
pub const cudaEventDisableTiming: u32 = 2;
pub const cudaEventInterprocess: u32 = 4;
pub const cudaDeviceScheduleAuto: u32 = 0;
pub const cudaDeviceScheduleSpin: u32 = 1;
pub const cudaDeviceScheduleYield: u32 = 2;
pub const cudaDeviceScheduleBlockingSync: u32 = 4;
pub const cudaDeviceBlockingSync: u32 = 4;
pub const cudaDeviceScheduleMask: u32 = 7;
pub const cudaDeviceMapHost: u32 = 8;
pub const cudaDeviceLmemResizeToMax: u32 = 16;
pub const cudaDeviceMask: u32 = 31;
pub const cudaArrayDefault: u32 = 0;
pub const cudaArrayLayered: u32 = 1;
pub const cudaArraySurfaceLoadStore: u32 = 2;
pub const cudaArrayCubemap: u32 = 4;
pub const cudaArrayTextureGather: u32 = 8;
pub const cudaArrayColorAttachment: u32 = 32;
pub const cudaIpcMemLazyEnablePeerAccess: u32 = 1;
pub const cudaMemAttachGlobal: u32 = 1;
pub const cudaMemAttachHost: u32 = 2;
pub const cudaMemAttachSingle: u32 = 4;
pub const cudaOccupancyDefault: u32 = 0;
pub const cudaOccupancyDisableCachingOverride: u32 = 1;
pub const cudaCooperativeLaunchMultiDeviceNoPreSync: u32 = 1;
pub const cudaCooperativeLaunchMultiDeviceNoPostSync: u32 = 2;
pub const cudaExternalMemoryDedicated: u32 = 1;
pub const cudaSurfaceType1D: u32 = 1;
pub const cudaSurfaceType2D: u32 = 2;
pub const cudaSurfaceType3D: u32 = 3;
pub const cudaSurfaceTypeCubemap: u32 = 12;
pub const cudaSurfaceType1DLayered: u32 = 241;
pub const cudaSurfaceType2DLayered: u32 = 242;
pub const cudaSurfaceTypeCubemapLayered: u32 = 252;
pub const cudaTextureType1D: u32 = 1;
pub const cudaTextureType2D: u32 = 2;
pub const cudaTextureType3D: u32 = 3;
pub const cudaTextureTypeCubemap: u32 = 12;
pub const cudaTextureType1DLayered: u32 = 241;
pub const cudaTextureType2DLayered: u32 = 242;
pub const cudaTextureTypeCubemapLayered: u32 = 252;
#[repr(i32)]
///                                                                              *
///                                                                              *
///                                                                              *
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum cudaRoundMode {
    cudaRoundNearest = 0,
    cudaRoundZero = 1,
    cudaRoundPosInf = 2,
    cudaRoundMinInf = 3,
}
#[repr(i32)]
/// CUDA error types
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum cudaError {
    /// The API call returned with no errors. In the case of query calls, this
    /// also means that the operation being queried is complete (see
    /// ::cudaEventQuery() and ::cudaStreamQuery()).
    cudaSuccess = 0,
    /// The device function being invoked (usually via ::cudaLaunchKernel()) was not
    /// previously configured via the ::cudaConfigureCall() function.
    cudaErrorMissingConfiguration = 1,
    /// The API call failed because it was unable to allocate enough memory to
    /// perform the requested operation.
    cudaErrorMemoryAllocation = 2,
    /// The API call failed because the CUDA driver and runtime could not be
    /// initialized.
    cudaErrorInitializationError = 3,
    /// An exception occurred on the device while executing a kernel. Common
    /// causes include dereferencing an invalid device pointer and accessing
    /// out of bounds shared memory. All existing device memory allocations
    /// are invalid. To continue using CUDA, the process must be terminated
    /// and relaunched.
    cudaErrorLaunchFailure = 4,
    /// This indicated that a previous kernel launch failed. This was previously
    /// used for device emulation of kernel launches.
    /// \deprecated
    /// This error return is deprecated as of CUDA 3.1. Device emulation mode was
    /// removed with the CUDA 3.1 release.
    cudaErrorPriorLaunchFailure = 5,
    /// This indicates that the device kernel took too long to execute. This can
    /// only occur if timeouts are enabled - see the device property
    /// \ref ::cudaDeviceProp::kernelExecTimeoutEnabled "kernelExecTimeoutEnabled"
    /// for more information.
    /// This leaves the process in an inconsistent state and any further CUDA work
    /// will return the same error. To continue using CUDA, the process must be terminated
    /// and relaunched.
    cudaErrorLaunchTimeout = 6,
    /// This indicates that a launch did not occur because it did not have
    /// appropriate resources. Although this error is similar to
    /// ::cudaErrorInvalidConfiguration, this error usually indicates that the
    /// user has attempted to pass too many arguments to the device kernel, or the
    /// kernel launch specifies too many threads for the kernel's register count.
    cudaErrorLaunchOutOfResources = 7,
    /// The requested device function does not exist or is not compiled for the
    /// proper device architecture.
    cudaErrorInvalidDeviceFunction = 8,
    /// This indicates that a kernel launch is requesting resources that can
    /// never be satisfied by the current device. Requesting more shared memory
    /// per block than the device supports will trigger this error, as will
    /// requesting too many threads or blocks. See ::cudaDeviceProp for more
    /// device limitations.
    cudaErrorInvalidConfiguration = 9,
    /// This indicates that the device ordinal supplied by the user does not
    /// correspond to a valid CUDA device.
    cudaErrorInvalidDevice = 10,
    /// This indicates that one or more of the parameters passed to the API call
    /// is not within an acceptable range of values.
    cudaErrorInvalidValue = 11,
    /// This indicates that one or more of the pitch-related parameters passed
    /// to the API call is not within the acceptable range for pitch.
    cudaErrorInvalidPitchValue = 12,
    /// This indicates that the symbol name/identifier passed to the API call
    /// is not a valid name or identifier.
    cudaErrorInvalidSymbol = 13,
    /// This indicates that the buffer object could not be mapped.
    cudaErrorMapBufferObjectFailed = 14,
    /// This indicates that the buffer object could not be unmapped.
    cudaErrorUnmapBufferObjectFailed = 15,
    /// This indicates that at least one host pointer passed to the API call is
    /// not a valid host pointer.
    cudaErrorInvalidHostPointer = 16,
    /// This indicates that at least one device pointer passed to the API call is
    /// not a valid device pointer.
    cudaErrorInvalidDevicePointer = 17,
    /// This indicates that the texture passed to the API call is not a valid
    /// texture.
    cudaErrorInvalidTexture = 18,
    /// This indicates that the texture binding is not valid. This occurs if you
    /// call ::cudaGetTextureAlignmentOffset() with an unbound texture.
    cudaErrorInvalidTextureBinding = 19,
    /// This indicates that the channel descriptor passed to the API call is not
    /// valid. This occurs if the format is not one of the formats specified by
    /// ::cudaChannelFormatKind, or if one of the dimensions is invalid.
    cudaErrorInvalidChannelDescriptor = 20,
    /// This indicates that the direction of the memcpy passed to the API call is
    /// not one of the types specified by ::cudaMemcpyKind.
    cudaErrorInvalidMemcpyDirection = 21,
    /// This indicated that the user has taken the address of a constant variable,
    /// which was forbidden up until the CUDA 3.1 release.
    /// \deprecated
    /// This error return is deprecated as of CUDA 3.1. Variables in constant
    /// memory may now have their address taken by the runtime via
    /// ::cudaGetSymbolAddress().
    cudaErrorAddressOfConstant = 22,
    /// This indicated that a texture fetch was not able to be performed.
    /// This was previously used for device emulation of texture operations.
    /// \deprecated
    /// This error return is deprecated as of CUDA 3.1. Device emulation mode was
    /// removed with the CUDA 3.1 release.
    cudaErrorTextureFetchFailed = 23,
    /// This indicated that a texture was not bound for access.
    /// This was previously used for device emulation of texture operations.
    /// \deprecated
    /// This error return is deprecated as of CUDA 3.1. Device emulation mode was
    /// removed with the CUDA 3.1 release.
    cudaErrorTextureNotBound = 24,
    /// This indicated that a synchronization operation had failed.
    /// This was previously used for some device emulation functions.
    /// \deprecated
    /// This error return is deprecated as of CUDA 3.1. Device emulation mode was
    /// removed with the CUDA 3.1 release.
    cudaErrorSynchronizationError = 25,
    /// This indicates that a non-float texture was being accessed with linear
    /// filtering. This is not supported by CUDA.
    cudaErrorInvalidFilterSetting = 26,
    /// This indicates that an attempt was made to read a non-float texture as a
    /// normalized float. This is not supported by CUDA.
    cudaErrorInvalidNormSetting = 27,
    /// Mixing of device and device emulation code was not allowed.
    /// \deprecated
    /// This error return is deprecated as of CUDA 3.1. Device emulation mode was
    /// removed with the CUDA 3.1 release.
    cudaErrorMixedDeviceExecution = 28,
    /// This indicates that a CUDA Runtime API call cannot be executed because
    /// it is being called during process shut down, at a point in time after
    /// CUDA driver has been unloaded.
    cudaErrorCudartUnloading = 29,
    /// This indicates that an unknown internal error has occurred.
    cudaErrorUnknown = 30,
    /// This indicates that the API call is not yet implemented. Production
    /// releases of CUDA will never return this error.
    /// \deprecated
    /// This error return is deprecated as of CUDA 4.1.
    cudaErrorNotYetImplemented = 31,
    /// This indicated that an emulated device pointer exceeded the 32-bit address
    /// range.
    /// \deprecated
    /// This error return is deprecated as of CUDA 3.1. Device emulation mode was
    /// removed with the CUDA 3.1 release.
    cudaErrorMemoryValueTooLarge = 32,
    /// This indicates that a resource handle passed to the API call was not
    /// valid. Resource handles are opaque types like ::cudaStream_t and
    /// ::cudaEvent_t.
    cudaErrorInvalidResourceHandle = 33,
    /// This indicates that asynchronous operations issued previously have not
    /// completed yet. This result is not actually an error, but must be indicated
    /// differently than ::cudaSuccess (which indicates completion). Calls that
    /// may return this value include ::cudaEventQuery() and ::cudaStreamQuery().
    cudaErrorNotReady = 34,
    /// This indicates that the installed NVIDIA CUDA driver is older than the
    /// CUDA runtime library. This is not a supported configuration. Users should
    /// install an updated NVIDIA display driver to allow the application to run.
    cudaErrorInsufficientDriver = 35,
    /// This indicates that the user has called ::cudaSetValidDevices(),
    /// ::cudaSetDeviceFlags(), ::cudaD3D9SetDirect3DDevice(),
    /// ::cudaD3D10SetDirect3DDevice, ::cudaD3D11SetDirect3DDevice(), or
    /// ::cudaVDPAUSetVDPAUDevice() after initializing the CUDA runtime by
    /// calling non-device management operations (allocating memory and
    /// launching kernels are examples of non-device management operations).
    /// This error can also be returned if using runtime/driver
    /// interoperability and there is an existing ::CUcontext active on the
    /// host thread.
    cudaErrorSetOnActiveProcess = 36,
    /// This indicates that the surface passed to the API call is not a valid
    /// surface.
    cudaErrorInvalidSurface = 37,
    /// This indicates that no CUDA-capable devices were detected by the installed
    /// CUDA driver.
    cudaErrorNoDevice = 38,
    /// This indicates that an uncorrectable ECC error was detected during
    /// execution.
    cudaErrorECCUncorrectable = 39,
    /// This indicates that a link to a shared object failed to resolve.
    cudaErrorSharedObjectSymbolNotFound = 40,
    /// This indicates that initialization of a shared object failed.
    cudaErrorSharedObjectInitFailed = 41,
    /// This indicates that the ::cudaLimit passed to the API call is not
    /// supported by the active device.
    cudaErrorUnsupportedLimit = 42,
    /// This indicates that multiple global or constant variables (across separate
    /// CUDA source files in the application) share the same string name.
    cudaErrorDuplicateVariableName = 43,
    /// This indicates that multiple textures (across separate CUDA source
    /// files in the application) share the same string name.
    cudaErrorDuplicateTextureName = 44,
    /// This indicates that multiple surfaces (across separate CUDA source
    /// files in the application) share the same string name.
    cudaErrorDuplicateSurfaceName = 45,
    /// This indicates that all CUDA devices are busy or unavailable at the current
    /// time. Devices are often busy/unavailable due to use of
    /// ::cudaComputeModeExclusive, ::cudaComputeModeProhibited or when long
    /// running CUDA kernels have filled up the GPU and are blocking new work
    /// from starting. They can also be unavailable due to memory constraints
    /// on a device that already has active CUDA work being performed.
    cudaErrorDevicesUnavailable = 46,
    /// This indicates that the device kernel image is invalid.
    cudaErrorInvalidKernelImage = 47,
    /// This indicates that there is no kernel image available that is suitable
    /// for the device. This can occur when a user specifies code generation
    /// options for a particular CUDA source file that do not include the
    /// corresponding device configuration.
    cudaErrorNoKernelImageForDevice = 48,
    /// This indicates that the current context is not compatible with this
    /// the CUDA Runtime. This can only occur if you are using CUDA
    /// Runtime/Driver interoperability and have created an existing Driver
    /// context using the driver API. The Driver context may be incompatible
    /// either because the Driver context was created using an older version
    /// of the API, because the Runtime API call expects a primary driver
    /// context and the Driver context is not primary, or because the Driver
    /// context has been destroyed. Please see \ref CUDART_DRIVER "Interactions
    /// with the CUDA Driver API" for more information.
    cudaErrorIncompatibleDriverContext = 49,
    /// This error indicates that a call to ::cudaDeviceEnablePeerAccess() is
    /// trying to re-enable peer addressing on from a context which has already
    /// had peer addressing enabled.
    cudaErrorPeerAccessAlreadyEnabled = 50,
    /// This error indicates that ::cudaDeviceDisablePeerAccess() is trying to
    /// disable peer addressing which has not been enabled yet via
    /// ::cudaDeviceEnablePeerAccess().
    cudaErrorPeerAccessNotEnabled = 51,
    /// This indicates that a call tried to access an exclusive-thread device that
    /// is already in use by a different thread.
    cudaErrorDeviceAlreadyInUse = 54,
    /// This indicates profiler is not initialized for this run. This can
    /// happen when the application is running with external profiling tools
    /// like visual profiler.
    cudaErrorProfilerDisabled = 55,
    /// \deprecated
    /// This error return is deprecated as of CUDA 5.0. It is no longer an error
    /// to attempt to enable/disable the profiling via ::cudaProfilerStart or
    /// ::cudaProfilerStop without initialization.
    cudaErrorProfilerNotInitialized = 56,
    /// \deprecated
    /// This error return is deprecated as of CUDA 5.0. It is no longer an error
    /// to call cudaProfilerStart() when profiling is already enabled.
    cudaErrorProfilerAlreadyStarted = 57,
    /// \deprecated
    /// This error return is deprecated as of CUDA 5.0. It is no longer an error
    /// to call cudaProfilerStop() when profiling is already disabled.
    cudaErrorProfilerAlreadyStopped = 58,
    /// An assert triggered in device code during kernel execution. The device
    /// cannot be used again. All existing allocations are invalid. To continue
    /// using CUDA, the process must be terminated and relaunched.
    cudaErrorAssert = 59,
    /// This error indicates that the hardware resources required to enable
    /// peer access have been exhausted for one or more of the devices
    /// passed to ::cudaEnablePeerAccess().
    cudaErrorTooManyPeers = 60,
    /// This error indicates that the memory range passed to ::cudaHostRegister()
    /// has already been registered.
    cudaErrorHostMemoryAlreadyRegistered = 61,
    /// This error indicates that the pointer passed to ::cudaHostUnregister()
    /// does not correspond to any currently registered memory region.
    cudaErrorHostMemoryNotRegistered = 62,
    /// This error indicates that an OS call failed.
    cudaErrorOperatingSystem = 63,
    /// This error indicates that P2P access is not supported across the given
    /// devices.
    cudaErrorPeerAccessUnsupported = 64,
    /// This error indicates that a device runtime grid launch did not occur
    /// because the depth of the child grid would exceed the maximum supported
    /// number of nested grid launches.
    cudaErrorLaunchMaxDepthExceeded = 65,
    /// This error indicates that a grid launch did not occur because the kernel
    /// uses file-scoped textures which are unsupported by the device runtime.
    /// Kernels launched via the device runtime only support textures created with
    /// the Texture Object API's.
    cudaErrorLaunchFileScopedTex = 66,
    /// This error indicates that a grid launch did not occur because the kernel
    /// uses file-scoped surfaces which are unsupported by the device runtime.
    /// Kernels launched via the device runtime only support surfaces created with
    /// the Surface Object API's.
    cudaErrorLaunchFileScopedSurf = 67,
    /// This error indicates that a call to ::cudaDeviceSynchronize made from
    /// the device runtime failed because the call was made at grid depth greater
    /// than than either the default (2 levels of grids) or user specified device
    /// limit ::cudaLimitDevRuntimeSyncDepth. To be able to synchronize on
    /// launched grids at a greater depth successfully, the maximum nested
    /// depth at which ::cudaDeviceSynchronize will be called must be specified
    /// with the ::cudaLimitDevRuntimeSyncDepth limit to the ::cudaDeviceSetLimit
    /// api before the host-side launch of a kernel using the device runtime.
    /// Keep in mind that additional levels of sync depth require the runtime
    /// to reserve large amounts of device memory that cannot be used for
    /// user allocations.
    cudaErrorSyncDepthExceeded = 68,
    /// This error indicates that a device runtime grid launch failed because
    /// the launch would exceed the limit ::cudaLimitDevRuntimePendingLaunchCount.
    /// For this launch to proceed successfully, ::cudaDeviceSetLimit must be
    /// called to set the ::cudaLimitDevRuntimePendingLaunchCount to be higher
    /// than the upper bound of outstanding launches that can be issued to the
    /// device runtime. Keep in mind that raising the limit of pending device
    /// runtime launches will require the runtime to reserve device memory that
    /// cannot be used for user allocations.
    cudaErrorLaunchPendingCountExceeded = 69,
    /// This error indicates the attempted operation is not permitted.
    cudaErrorNotPermitted = 70,
    /// This error indicates the attempted operation is not supported
    /// on the current system or device.
    cudaErrorNotSupported = 71,
    /// Device encountered an error in the call stack during kernel execution,
    /// possibly due to stack corruption or exceeding the stack size limit.
    /// This leaves the process in an inconsistent state and any further CUDA work
    /// will return the same error. To continue using CUDA, the process must be terminated
    /// and relaunched.
    cudaErrorHardwareStackError = 72,
    /// The device encountered an illegal instruction during kernel execution
    /// This leaves the process in an inconsistent state and any further CUDA work
    /// will return the same error. To continue using CUDA, the process must be terminated
    /// and relaunched.
    cudaErrorIllegalInstruction = 73,
    /// The device encountered a load or store instruction
    /// on a memory address which is not aligned.
    /// This leaves the process in an inconsistent state and any further CUDA work
    /// will return the same error. To continue using CUDA, the process must be terminated
    /// and relaunched.
    cudaErrorMisalignedAddress = 74,
    /// While executing a kernel, the device encountered an instruction
    /// which can only operate on memory locations in certain address spaces
    /// (global, shared, or local), but was supplied a memory address not
    /// belonging to an allowed address space.
    /// This leaves the process in an inconsistent state and any further CUDA work
    /// will return the same error. To continue using CUDA, the process must be terminated
    /// and relaunched.
    cudaErrorInvalidAddressSpace = 75,
    /// The device encountered an invalid program counter.
    /// This leaves the process in an inconsistent state and any further CUDA work
    /// will return the same error. To continue using CUDA, the process must be terminated
    /// and relaunched.
    cudaErrorInvalidPc = 76,
    /// The device encountered a load or store instruction on an invalid memory address.
    /// This leaves the process in an inconsistent state and any further CUDA work
    /// will return the same error. To continue using CUDA, the process must be terminated
    /// and relaunched.
    cudaErrorIllegalAddress = 77,
    /// A PTX compilation failed. The runtime may fall back to compiling PTX if
    /// an application does not contain a suitable binary for the current device.
    cudaErrorInvalidPtx = 78,
    /// This indicates an error with the OpenGL or DirectX context.
    cudaErrorInvalidGraphicsContext = 79,
    /// This indicates that an uncorrectable NVLink error was detected during the
    /// execution.
    cudaErrorNvlinkUncorrectable = 80,
    /// This indicates that the PTX JIT compiler library was not found. The JIT Compiler
    /// library is used for PTX compilation. The runtime may fall back to compiling PTX
    /// if an application does not contain a suitable binary for the current device.
    cudaErrorJitCompilerNotFound = 81,
    /// This error indicates that the number of blocks launched per grid for a kernel that was
    /// launched via either ::cudaLaunchCooperativeKernel or ::cudaLaunchCooperativeKernelMultiDevice
    /// exceeds the maximum number of blocks as allowed by ::cudaOccupancyMaxActiveBlocksPerMultiprocessor
    /// or ::cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags times the number of multiprocessors
    /// as specified by the device attribute ::cudaDevAttrMultiProcessorCount.
    cudaErrorCooperativeLaunchTooLarge = 82,
    /// This error indicates that the system is not yet ready to start any CUDA
    /// work.  To continue using CUDA, verify the system configuration is in a
    /// valid state and all required driver daemons are actively running.
    cudaErrorSystemNotReady = 83,
    /// This indicates that a resource required by the API call is not in a
    /// valid state to perform the requested operation.
    cudaErrorIllegalState = 84,
    /// This indicates an internal startup failure in the CUDA runtime.
    cudaErrorStartupFailure = 127,
    /// The operation is not permitted when the stream is capturing.
    cudaErrorStreamCaptureUnsupported = 900,
    /// The current capture sequence on the stream has been invalidated due to
    /// a previous error.
    cudaErrorStreamCaptureInvalidated = 901,
    /// The operation would have resulted in a merge of two independent capture
    /// sequences.
    cudaErrorStreamCaptureMerge = 902,
    /// The capture was not initiated in this stream.
    cudaErrorStreamCaptureUnmatched = 903,
    /// The capture sequence contains a fork that was not joined to the primary
    /// stream.
    cudaErrorStreamCaptureUnjoined = 904,
    /// A dependency would have been created which crosses the capture sequence
    /// boundary. Only implicit in-stream ordering dependencies are allowed to
    /// cross the boundary.
    cudaErrorStreamCaptureIsolation = 905,
    /// The operation would have resulted in a disallowed implicit dependency on
    /// a current capture sequence from cudaStreamLegacy.
    cudaErrorStreamCaptureImplicit = 906,
    /// The operation is not permitted on an event which was last recorded in a
    /// capturing stream.
    cudaErrorCapturedEvent = 907,
    /// Any unhandled CUDA driver error is added to this value and returned via
    /// the runtime. Production releases of CUDA should not return such errors.
    /// \deprecated
    /// This error return is deprecated as of CUDA 4.1.
    cudaErrorApiFailureBase = 10000,
}
#[repr(i32)]
/// Channel format kind
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum cudaChannelFormatKind {
    ///< Signed channel format
    cudaChannelFormatKindSigned = 0,
    ///< Unsigned channel format
    cudaChannelFormatKindUnsigned = 1,
    ///< Float channel format
    cudaChannelFormatKindFloat = 2,
    ///< No channel format
    cudaChannelFormatKindNone = 3,
}
/// CUDA Channel format descriptor
#[repr(C)]
pub struct cudaChannelFormatDesc {
    ///< x
    pub x: ::std::os::raw::c_int,
    ///< y
    pub y: ::std::os::raw::c_int,
    ///< z
    pub z: ::std::os::raw::c_int,
    ///< w
    pub w: ::std::os::raw::c_int,
    ///< Channel format kind
    pub f: cudaChannelFormatKind,
}
#[test]
fn bindgen_test_layout_cudaChannelFormatDesc() {
    assert_eq!(
        ::std::mem::size_of::<cudaChannelFormatDesc>(),
        20usize,
        concat!("Size of: ", stringify!(cudaChannelFormatDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaChannelFormatDesc>(),
        4usize,
        concat!("Alignment of ", stringify!(cudaChannelFormatDesc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaChannelFormatDesc>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaChannelFormatDesc),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaChannelFormatDesc>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaChannelFormatDesc),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaChannelFormatDesc>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaChannelFormatDesc),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaChannelFormatDesc>())).w as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaChannelFormatDesc),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaChannelFormatDesc>())).f as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaChannelFormatDesc),
            "::",
            stringify!(f)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaArray {
    _unused: [u8; 0],
}
/// CUDA array
pub type cudaArray_t = *mut cudaArray;
/// CUDA array (as source copy argument)
pub type cudaArray_const_t = *const cudaArray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaMipmappedArray {
    _unused: [u8; 0],
}
/// CUDA mipmapped array
pub type cudaMipmappedArray_t = *mut cudaMipmappedArray;
/// CUDA mipmapped array (as source argument)
pub type cudaMipmappedArray_const_t = *const cudaMipmappedArray;
#[repr(i32)]
/// CUDA memory types
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum cudaMemoryType {
    ///< Unregistered memory
    cudaMemoryTypeUnregistered = 0,
    ///< Host memory
    cudaMemoryTypeHost = 1,
    ///< Device memory
    cudaMemoryTypeDevice = 2,
    ///< Managed memory
    cudaMemoryTypeManaged = 3,
}
#[repr(i32)]
/// CUDA memory copy types
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum cudaMemcpyKind {
    ///< Host   -> Host
    cudaMemcpyHostToHost = 0,
    ///< Host   -> Device
    cudaMemcpyHostToDevice = 1,
    ///< Device -> Host
    cudaMemcpyDeviceToHost = 2,
    ///< Device -> Device
    cudaMemcpyDeviceToDevice = 3,
    ///< Direction of the transfer is inferred from the pointer values. Requires unified virtual addressing
    cudaMemcpyDefault = 4,
}
/// CUDA Pitched memory pointer
///
/// \sa ::make_cudaPitchedPtr
#[repr(C)]
pub struct cudaPitchedPtr {
    ///< Pointer to allocated memory
    pub ptr: *mut ::std::os::raw::c_void,
    ///< Pitch of allocated memory in bytes
    pub pitch: usize,
    ///< Logical width of allocation in elements
    pub xsize: usize,
    ///< Logical height of allocation in elements
    pub ysize: usize,
}
#[test]
fn bindgen_test_layout_cudaPitchedPtr() {
    assert_eq!(
        ::std::mem::size_of::<cudaPitchedPtr>(),
        32usize,
        concat!("Size of: ", stringify!(cudaPitchedPtr))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaPitchedPtr>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaPitchedPtr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaPitchedPtr>())).ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaPitchedPtr),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaPitchedPtr>())).pitch as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaPitchedPtr),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaPitchedPtr>())).xsize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaPitchedPtr),
            "::",
            stringify!(xsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaPitchedPtr>())).ysize as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaPitchedPtr),
            "::",
            stringify!(ysize)
        )
    );
}
/// CUDA extent
///
/// \sa ::make_cudaExtent
#[repr(C)]
pub struct cudaExtent {
    ///< Width in elements when referring to array memory, in bytes when referring to linear memory
    pub width: usize,
    ///< Height in elements
    pub height: usize,
    ///< Depth in elements
    pub depth: usize,
}
#[test]
fn bindgen_test_layout_cudaExtent() {
    assert_eq!(
        ::std::mem::size_of::<cudaExtent>(),
        24usize,
        concat!("Size of: ", stringify!(cudaExtent))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExtent>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaExtent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaExtent>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExtent),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaExtent>())).height as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExtent),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaExtent>())).depth as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExtent),
            "::",
            stringify!(depth)
        )
    );
}
/// CUDA 3D position
///
/// \sa ::make_cudaPos
#[repr(C)]
pub struct cudaPos {
    ///< x
    pub x: usize,
    ///< y
    pub y: usize,
    ///< z
    pub z: usize,
}
#[test]
fn bindgen_test_layout_cudaPos() {
    assert_eq!(
        ::std::mem::size_of::<cudaPos>(),
        24usize,
        concat!("Size of: ", stringify!(cudaPos))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaPos>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaPos))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaPos>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaPos),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaPos>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaPos),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaPos>())).z as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaPos),
            "::",
            stringify!(z)
        )
    );
}
/// CUDA 3D memory copying parameters
#[repr(C)]
pub struct cudaMemcpy3DParms {
    ///< Source memory address
    pub srcArray: cudaArray_t,
    ///< Source position offset
    pub srcPos: cudaPos,
    ///< Pitched source memory address
    pub srcPtr: cudaPitchedPtr,
    ///< Destination memory address
    pub dstArray: cudaArray_t,
    ///< Destination position offset
    pub dstPos: cudaPos,
    ///< Pitched destination memory address
    pub dstPtr: cudaPitchedPtr,
    ///< Requested memory copy size
    pub extent: cudaExtent,
    ///< Type of transfer
    pub kind: cudaMemcpyKind,
}
#[test]
fn bindgen_test_layout_cudaMemcpy3DParms() {
    assert_eq!(
        ::std::mem::size_of::<cudaMemcpy3DParms>(),
        160usize,
        concat!("Size of: ", stringify!(cudaMemcpy3DParms))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaMemcpy3DParms>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaMemcpy3DParms))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemcpy3DParms>())).srcArray as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemcpy3DParms),
            "::",
            stringify!(srcArray)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemcpy3DParms>())).srcPos as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemcpy3DParms),
            "::",
            stringify!(srcPos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemcpy3DParms>())).srcPtr as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemcpy3DParms),
            "::",
            stringify!(srcPtr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemcpy3DParms>())).dstArray as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemcpy3DParms),
            "::",
            stringify!(dstArray)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemcpy3DParms>())).dstPos as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemcpy3DParms),
            "::",
            stringify!(dstPos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemcpy3DParms>())).dstPtr as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemcpy3DParms),
            "::",
            stringify!(dstPtr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemcpy3DParms>())).extent as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemcpy3DParms),
            "::",
            stringify!(extent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemcpy3DParms>())).kind as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemcpy3DParms),
            "::",
            stringify!(kind)
        )
    );
}
/// CUDA 3D cross-device memory copying parameters
#[repr(C)]
pub struct cudaMemcpy3DPeerParms {
    ///< Source memory address
    pub srcArray: cudaArray_t,
    ///< Source position offset
    pub srcPos: cudaPos,
    ///< Pitched source memory address
    pub srcPtr: cudaPitchedPtr,
    ///< Source device
    pub srcDevice: ::std::os::raw::c_int,
    ///< Destination memory address
    pub dstArray: cudaArray_t,
    ///< Destination position offset
    pub dstPos: cudaPos,
    ///< Pitched destination memory address
    pub dstPtr: cudaPitchedPtr,
    ///< Destination device
    pub dstDevice: ::std::os::raw::c_int,
    ///< Requested memory copy size
    pub extent: cudaExtent,
}
#[test]
fn bindgen_test_layout_cudaMemcpy3DPeerParms() {
    assert_eq!(
        ::std::mem::size_of::<cudaMemcpy3DPeerParms>(),
        168usize,
        concat!("Size of: ", stringify!(cudaMemcpy3DPeerParms))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaMemcpy3DPeerParms>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaMemcpy3DPeerParms))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemcpy3DPeerParms>())).srcArray as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemcpy3DPeerParms),
            "::",
            stringify!(srcArray)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemcpy3DPeerParms>())).srcPos as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemcpy3DPeerParms),
            "::",
            stringify!(srcPos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemcpy3DPeerParms>())).srcPtr as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemcpy3DPeerParms),
            "::",
            stringify!(srcPtr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemcpy3DPeerParms>())).srcDevice as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemcpy3DPeerParms),
            "::",
            stringify!(srcDevice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemcpy3DPeerParms>())).dstArray as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemcpy3DPeerParms),
            "::",
            stringify!(dstArray)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemcpy3DPeerParms>())).dstPos as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemcpy3DPeerParms),
            "::",
            stringify!(dstPos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemcpy3DPeerParms>())).dstPtr as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemcpy3DPeerParms),
            "::",
            stringify!(dstPtr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemcpy3DPeerParms>())).dstDevice as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemcpy3DPeerParms),
            "::",
            stringify!(dstDevice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemcpy3DPeerParms>())).extent as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemcpy3DPeerParms),
            "::",
            stringify!(extent)
        )
    );
}
/// CUDA Memset node parameters
#[repr(C)]
pub struct cudaMemsetParams {
    ///< Destination device pointer
    pub dst: *mut ::std::os::raw::c_void,
    ///< Pitch of destination device pointer. Unused if height is 1
    pub pitch: usize,
    ///< Value to be set
    pub value: ::std::os::raw::c_uint,
    ///< Size of each element in bytes. Must be 1, 2, or 4.
    pub elementSize: ::std::os::raw::c_uint,
    ///< Width in bytes, of the row
    pub width: usize,
    ///< Number of rows
    pub height: usize,
}
#[test]
fn bindgen_test_layout_cudaMemsetParams() {
    assert_eq!(
        ::std::mem::size_of::<cudaMemsetParams>(),
        40usize,
        concat!("Size of: ", stringify!(cudaMemsetParams))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaMemsetParams>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaMemsetParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemsetParams>())).dst as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemsetParams),
            "::",
            stringify!(dst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemsetParams>())).pitch as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemsetParams),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemsetParams>())).value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemsetParams),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemsetParams>())).elementSize as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemsetParams),
            "::",
            stringify!(elementSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemsetParams>())).width as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemsetParams),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemsetParams>())).height as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemsetParams),
            "::",
            stringify!(height)
        )
    );
}
/// CUDA host function
/// \param userData Argument value passed to the function
pub type cudaHostFn_t =
    ::std::option::Option<unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void)>;
/// CUDA host node parameters
#[repr(C)]
pub struct cudaHostNodeParams {
    ///< The function to call when the node executes
    pub fn_: cudaHostFn_t,
    ///< Argument to pass to the function
    pub userData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_cudaHostNodeParams() {
    assert_eq!(
        ::std::mem::size_of::<cudaHostNodeParams>(),
        16usize,
        concat!("Size of: ", stringify!(cudaHostNodeParams))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaHostNodeParams>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaHostNodeParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaHostNodeParams>())).fn_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaHostNodeParams),
            "::",
            stringify!(fn_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaHostNodeParams>())).userData as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaHostNodeParams),
            "::",
            stringify!(userData)
        )
    );
}
#[repr(i32)]
/// Possible stream capture statuses returned by ::cudaStreamIsCapturing
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum cudaStreamCaptureStatus {
    ///< Stream is not capturing
    cudaStreamCaptureStatusNone = 0,
    ///< Stream is actively capturing
    cudaStreamCaptureStatusActive = 1,
    ///< Stream is part of a capture sequence that
    ///has been invalidated, but not terminated
    cudaStreamCaptureStatusInvalidated = 2,
}
/// CUDA graphics interop resource
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaGraphicsResource {
    _unused: [u8; 0],
}
#[repr(i32)]
/// CUDA graphics interop register flags
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum cudaGraphicsRegisterFlags {
    ///< Default
    cudaGraphicsRegisterFlagsNone = 0,
    ///< CUDA will not write to this resource
    cudaGraphicsRegisterFlagsReadOnly = 1,
    ///< CUDA will only write to and will not read from this resource
    cudaGraphicsRegisterFlagsWriteDiscard = 2,
    ///< CUDA will bind this resource to a surface reference
    cudaGraphicsRegisterFlagsSurfaceLoadStore = 4,
    ///< CUDA will perform texture gather operations on this resource
    cudaGraphicsRegisterFlagsTextureGather = 8,
}
#[repr(i32)]
/// CUDA graphics interop map flags
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum cudaGraphicsMapFlags {
    ///< Default; Assume resource can be read/written
    cudaGraphicsMapFlagsNone = 0,
    ///< CUDA will not write to this resource
    cudaGraphicsMapFlagsReadOnly = 1,
    ///< CUDA will only write to and will not read from this resource
    cudaGraphicsMapFlagsWriteDiscard = 2,
}
#[repr(i32)]
/// CUDA graphics interop array indices for cube maps
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum cudaGraphicsCubeFace {
    ///< Positive X face of cubemap
    cudaGraphicsCubeFacePositiveX = 0,
    ///< Negative X face of cubemap
    cudaGraphicsCubeFaceNegativeX = 1,
    ///< Positive Y face of cubemap
    cudaGraphicsCubeFacePositiveY = 2,
    ///< Negative Y face of cubemap
    cudaGraphicsCubeFaceNegativeY = 3,
    ///< Positive Z face of cubemap
    cudaGraphicsCubeFacePositiveZ = 4,
    ///< Negative Z face of cubemap
    cudaGraphicsCubeFaceNegativeZ = 5,
}
#[repr(i32)]
/// CUDA resource types
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum cudaResourceType {
    ///< Array resource
    cudaResourceTypeArray = 0,
    ///< Mipmapped array resource
    cudaResourceTypeMipmappedArray = 1,
    ///< Linear resource
    cudaResourceTypeLinear = 2,
    ///< Pitch 2D resource
    cudaResourceTypePitch2D = 3,
}
#[repr(i32)]
/// CUDA texture resource view formats
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum cudaResourceViewFormat {
    ///< No resource view format (use underlying resource format)
    cudaResViewFormatNone = 0,
    ///< 1 channel unsigned 8-bit integers
    cudaResViewFormatUnsignedChar1 = 1,
    ///< 2 channel unsigned 8-bit integers
    cudaResViewFormatUnsignedChar2 = 2,
    ///< 4 channel unsigned 8-bit integers
    cudaResViewFormatUnsignedChar4 = 3,
    ///< 1 channel signed 8-bit integers
    cudaResViewFormatSignedChar1 = 4,
    ///< 2 channel signed 8-bit integers
    cudaResViewFormatSignedChar2 = 5,
    ///< 4 channel signed 8-bit integers
    cudaResViewFormatSignedChar4 = 6,
    ///< 1 channel unsigned 16-bit integers
    cudaResViewFormatUnsignedShort1 = 7,
    ///< 2 channel unsigned 16-bit integers
    cudaResViewFormatUnsignedShort2 = 8,
    ///< 4 channel unsigned 16-bit integers
    cudaResViewFormatUnsignedShort4 = 9,
    ///< 1 channel signed 16-bit integers
    cudaResViewFormatSignedShort1 = 10,
    ///< 2 channel signed 16-bit integers
    cudaResViewFormatSignedShort2 = 11,
    ///< 4 channel signed 16-bit integers
    cudaResViewFormatSignedShort4 = 12,
    ///< 1 channel unsigned 32-bit integers
    cudaResViewFormatUnsignedInt1 = 13,
    ///< 2 channel unsigned 32-bit integers
    cudaResViewFormatUnsignedInt2 = 14,
    ///< 4 channel unsigned 32-bit integers
    cudaResViewFormatUnsignedInt4 = 15,
    ///< 1 channel signed 32-bit integers
    cudaResViewFormatSignedInt1 = 16,
    ///< 2 channel signed 32-bit integers
    cudaResViewFormatSignedInt2 = 17,
    ///< 4 channel signed 32-bit integers
    cudaResViewFormatSignedInt4 = 18,
    ///< 1 channel 16-bit floating point
    cudaResViewFormatHalf1 = 19,
    ///< 2 channel 16-bit floating point
    cudaResViewFormatHalf2 = 20,
    ///< 4 channel 16-bit floating point
    cudaResViewFormatHalf4 = 21,
    ///< 1 channel 32-bit floating point
    cudaResViewFormatFloat1 = 22,
    ///< 2 channel 32-bit floating point
    cudaResViewFormatFloat2 = 23,
    ///< 4 channel 32-bit floating point
    cudaResViewFormatFloat4 = 24,
    ///< Block compressed 1
    cudaResViewFormatUnsignedBlockCompressed1 = 25,
    ///< Block compressed 2
    cudaResViewFormatUnsignedBlockCompressed2 = 26,
    ///< Block compressed 3
    cudaResViewFormatUnsignedBlockCompressed3 = 27,
    ///< Block compressed 4 unsigned
    cudaResViewFormatUnsignedBlockCompressed4 = 28,
    ///< Block compressed 4 signed
    cudaResViewFormatSignedBlockCompressed4 = 29,
    ///< Block compressed 5 unsigned
    cudaResViewFormatUnsignedBlockCompressed5 = 30,
    ///< Block compressed 5 signed
    cudaResViewFormatSignedBlockCompressed5 = 31,
    ///< Block compressed 6 unsigned half-float
    cudaResViewFormatUnsignedBlockCompressed6H = 32,
    ///< Block compressed 6 signed half-float
    cudaResViewFormatSignedBlockCompressed6H = 33,
    ///< Block compressed 7
    cudaResViewFormatUnsignedBlockCompressed7 = 34,
}
/// CUDA resource descriptor
#[repr(C)]
pub struct cudaResourceDesc {
    ///< Resource type
    pub resType: cudaResourceType,
    pub res: cudaResourceDesc__bindgen_ty_1,
}
#[repr(C)]
pub struct cudaResourceDesc__bindgen_ty_1 {
    pub array: __BindgenUnionField<cudaResourceDesc__bindgen_ty_1__bindgen_ty_1>,
    pub mipmap: __BindgenUnionField<cudaResourceDesc__bindgen_ty_1__bindgen_ty_2>,
    pub linear: __BindgenUnionField<cudaResourceDesc__bindgen_ty_1__bindgen_ty_3>,
    pub pitch2D: __BindgenUnionField<cudaResourceDesc__bindgen_ty_1__bindgen_ty_4>,
    pub bindgen_union_field: [u64; 7usize],
}
#[repr(C)]
pub struct cudaResourceDesc__bindgen_ty_1__bindgen_ty_1 {
    ///< CUDA array
    pub array: cudaArray_t,
}
#[test]
fn bindgen_test_layout_cudaResourceDesc__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_1>())).array
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(array)
        )
    );
}
#[repr(C)]
pub struct cudaResourceDesc__bindgen_ty_1__bindgen_ty_2 {
    ///< CUDA mipmapped array
    pub mipmap: cudaMipmappedArray_t,
}
#[test]
fn bindgen_test_layout_cudaResourceDesc__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_2>())).mipmap
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(mipmap)
        )
    );
}
#[repr(C)]
pub struct cudaResourceDesc__bindgen_ty_1__bindgen_ty_3 {
    ///< Device pointer
    pub devPtr: *mut ::std::os::raw::c_void,
    ///< Channel descriptor
    pub desc: cudaChannelFormatDesc,
    ///< Size in bytes
    pub sizeInBytes: usize,
}
#[test]
fn bindgen_test_layout_cudaResourceDesc__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_3>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_3>())).devPtr
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(devPtr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_3>())).desc
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_3>())).sizeInBytes
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(sizeInBytes)
        )
    );
}
#[repr(C)]
pub struct cudaResourceDesc__bindgen_ty_1__bindgen_ty_4 {
    ///< Device pointer
    pub devPtr: *mut ::std::os::raw::c_void,
    ///< Channel descriptor
    pub desc: cudaChannelFormatDesc,
    ///< Width of the array in elements
    pub width: usize,
    ///< Height of the array in elements
    pub height: usize,
    ///< Pitch between two rows in bytes
    pub pitchInBytes: usize,
}
#[test]
fn bindgen_test_layout_cudaResourceDesc__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_4>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_4>())).devPtr
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(devPtr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_4>())).desc
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_4>())).width
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_4>())).height
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_4>())).pitchInBytes
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(pitchInBytes)
        )
    );
}
#[test]
fn bindgen_test_layout_cudaResourceDesc__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaResourceDesc__bindgen_ty_1>(),
        56usize,
        concat!("Size of: ", stringify!(cudaResourceDesc__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaResourceDesc__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaResourceDesc__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaResourceDesc__bindgen_ty_1>())).array as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceDesc__bindgen_ty_1),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaResourceDesc__bindgen_ty_1>())).mipmap as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceDesc__bindgen_ty_1),
            "::",
            stringify!(mipmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaResourceDesc__bindgen_ty_1>())).linear as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceDesc__bindgen_ty_1),
            "::",
            stringify!(linear)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaResourceDesc__bindgen_ty_1>())).pitch2D as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceDesc__bindgen_ty_1),
            "::",
            stringify!(pitch2D)
        )
    );
}
#[test]
fn bindgen_test_layout_cudaResourceDesc() {
    assert_eq!(
        ::std::mem::size_of::<cudaResourceDesc>(),
        64usize,
        concat!("Size of: ", stringify!(cudaResourceDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaResourceDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaResourceDesc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaResourceDesc>())).resType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceDesc),
            "::",
            stringify!(resType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaResourceDesc>())).res as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceDesc),
            "::",
            stringify!(res)
        )
    );
}
/// CUDA resource view descriptor
#[repr(C)]
pub struct cudaResourceViewDesc {
    ///< Resource view format
    pub format: cudaResourceViewFormat,
    ///< Width of the resource view
    pub width: usize,
    ///< Height of the resource view
    pub height: usize,
    ///< Depth of the resource view
    pub depth: usize,
    ///< First defined mipmap level
    pub firstMipmapLevel: ::std::os::raw::c_uint,
    ///< Last defined mipmap level
    pub lastMipmapLevel: ::std::os::raw::c_uint,
    ///< First layer index
    pub firstLayer: ::std::os::raw::c_uint,
    ///< Last layer index
    pub lastLayer: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_cudaResourceViewDesc() {
    assert_eq!(
        ::std::mem::size_of::<cudaResourceViewDesc>(),
        48usize,
        concat!("Size of: ", stringify!(cudaResourceViewDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaResourceViewDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaResourceViewDesc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaResourceViewDesc>())).format as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceViewDesc),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaResourceViewDesc>())).width as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceViewDesc),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaResourceViewDesc>())).height as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceViewDesc),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaResourceViewDesc>())).depth as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceViewDesc),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaResourceViewDesc>())).firstMipmapLevel as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceViewDesc),
            "::",
            stringify!(firstMipmapLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaResourceViewDesc>())).lastMipmapLevel as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceViewDesc),
            "::",
            stringify!(lastMipmapLevel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaResourceViewDesc>())).firstLayer as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceViewDesc),
            "::",
            stringify!(firstLayer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaResourceViewDesc>())).lastLayer as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceViewDesc),
            "::",
            stringify!(lastLayer)
        )
    );
}
/// CUDA pointer attributes
#[repr(C)]
pub struct cudaPointerAttributes {
    /// \deprecated
    ///
    /// The physical location of the memory, ::cudaMemoryTypeHost or
    /// ::cudaMemoryTypeDevice. Note that managed memory can return either
    /// ::cudaMemoryTypeDevice or ::cudaMemoryTypeHost regardless of it's
    /// physical location.
    pub memoryType: cudaMemoryType,
    /// The type of memory - ::cudaMemoryTypeUnregistered, ::cudaMemoryTypeHost,
    /// ::cudaMemoryTypeDevice or ::cudaMemoryTypeManaged.
    pub type_: cudaMemoryType,
    /// The device against which the memory was allocated or registered.
    /// If the memory type is ::cudaMemoryTypeDevice then this identifies
    /// the device on which the memory referred physically resides.  If
    /// the memory type is ::cudaMemoryTypeHost or::cudaMemoryTypeManaged then
    /// this identifies the device which was current when the memory was allocated
    /// or registered (and if that device is deinitialized then this allocation
    /// will vanish with that device's state).
    pub device: ::std::os::raw::c_int,
    /// The address which may be dereferenced on the current device to access
    /// the memory or NULL if no such address exists.
    pub devicePointer: *mut ::std::os::raw::c_void,
    /// The address which may be dereferenced on the host to access the
    /// memory or NULL if no such address exists.
    ///
    /// \note CUDA doesn't check if unregistered memory is allocated so this field
    /// may contain invalid pointer if an invalid pointer has been passed to CUDA.
    pub hostPointer: *mut ::std::os::raw::c_void,
    /// \deprecated
    ///
    /// Indicates if this pointer points to managed memory
    pub isManaged: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cudaPointerAttributes() {
    assert_eq!(
        ::std::mem::size_of::<cudaPointerAttributes>(),
        40usize,
        concat!("Size of: ", stringify!(cudaPointerAttributes))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaPointerAttributes>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaPointerAttributes))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaPointerAttributes>())).memoryType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaPointerAttributes),
            "::",
            stringify!(memoryType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaPointerAttributes>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaPointerAttributes),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaPointerAttributes>())).device as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaPointerAttributes),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaPointerAttributes>())).devicePointer as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaPointerAttributes),
            "::",
            stringify!(devicePointer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaPointerAttributes>())).hostPointer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaPointerAttributes),
            "::",
            stringify!(hostPointer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaPointerAttributes>())).isManaged as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaPointerAttributes),
            "::",
            stringify!(isManaged)
        )
    );
}
/// CUDA function attributes
#[repr(C)]
pub struct cudaFuncAttributes {
    /// The size in bytes of statically-allocated shared memory per block
    /// required by this function. This does not include dynamically-allocated
    /// shared memory requested by the user at runtime.
    pub sharedSizeBytes: usize,
    /// The size in bytes of user-allocated constant memory required by this
    /// function.
    pub constSizeBytes: usize,
    /// The size in bytes of local memory used by each thread of this function.
    pub localSizeBytes: usize,
    /// The maximum number of threads per block, beyond which a launch of the
    /// function would fail. This number depends on both the function and the
    /// device on which the function is currently loaded.
    pub maxThreadsPerBlock: ::std::os::raw::c_int,
    /// The number of registers used by each thread of this function.
    pub numRegs: ::std::os::raw::c_int,
    /// The PTX virtual architecture version for which the function was
    /// compiled. This value is the major PTX version * 10 + the minor PTX
    /// version, so a PTX version 1.3 function would return the value 13.
    pub ptxVersion: ::std::os::raw::c_int,
    /// The binary architecture version for which the function was compiled.
    /// This value is the major binary version * 10 + the minor binary version,
    /// so a binary version 1.3 function would return the value 13.
    pub binaryVersion: ::std::os::raw::c_int,
    /// The attribute to indicate whether the function has been compiled with
    /// user specified option "-Xptxas --dlcm=ca" set.
    pub cacheModeCA: ::std::os::raw::c_int,
    /// The maximum size in bytes of dynamic shared memory per block for
    /// this function. Any launch must have a dynamic shared memory size
    /// smaller than this value.
    pub maxDynamicSharedSizeBytes: ::std::os::raw::c_int,
    /// On devices where the L1 cache and shared memory use the same hardware resources,
    /// this sets the shared memory carveout preference, in percent of the maximum shared memory.
    /// This is only a hint, and the driver can choose a different ratio if required to execute the function.
    pub preferredShmemCarveout: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cudaFuncAttributes() {
    assert_eq!(
        ::std::mem::size_of::<cudaFuncAttributes>(),
        56usize,
        concat!("Size of: ", stringify!(cudaFuncAttributes))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaFuncAttributes>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaFuncAttributes))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaFuncAttributes>())).sharedSizeBytes as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaFuncAttributes),
            "::",
            stringify!(sharedSizeBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaFuncAttributes>())).constSizeBytes as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaFuncAttributes),
            "::",
            stringify!(constSizeBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaFuncAttributes>())).localSizeBytes as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaFuncAttributes),
            "::",
            stringify!(localSizeBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaFuncAttributes>())).maxThreadsPerBlock as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaFuncAttributes),
            "::",
            stringify!(maxThreadsPerBlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaFuncAttributes>())).numRegs as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaFuncAttributes),
            "::",
            stringify!(numRegs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaFuncAttributes>())).ptxVersion as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaFuncAttributes),
            "::",
            stringify!(ptxVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaFuncAttributes>())).binaryVersion as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaFuncAttributes),
            "::",
            stringify!(binaryVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaFuncAttributes>())).cacheModeCA as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaFuncAttributes),
            "::",
            stringify!(cacheModeCA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaFuncAttributes>())).maxDynamicSharedSizeBytes as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaFuncAttributes),
            "::",
            stringify!(maxDynamicSharedSizeBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaFuncAttributes>())).preferredShmemCarveout as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaFuncAttributes),
            "::",
            stringify!(preferredShmemCarveout)
        )
    );
}
#[repr(i32)]
/// CUDA function attributes that can be set using cudaFuncSetAttribute
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum cudaFuncAttribute {
    ///< Maximum dynamic shared memory size
    cudaFuncAttributeMaxDynamicSharedMemorySize = 8,
    ///< Preferred shared memory-L1 cache split ratio
    cudaFuncAttributePreferredSharedMemoryCarveout = 9,
    cudaFuncAttributeMax = 10,
}
#[repr(i32)]
/// CUDA function cache configurations
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum cudaFuncCache {
    ///< Default function cache configuration, no preference
    cudaFuncCachePreferNone = 0,
    ///< Prefer larger shared memory and smaller L1 cache
    cudaFuncCachePreferShared = 1,
    ///< Prefer larger L1 cache and smaller shared memory
    cudaFuncCachePreferL1 = 2,
    ///< Prefer equal size L1 cache and shared memory
    cudaFuncCachePreferEqual = 3,
}
#[repr(i32)]
/// CUDA shared memory configuration
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum cudaSharedMemConfig {
    cudaSharedMemBankSizeDefault = 0,
    cudaSharedMemBankSizeFourByte = 1,
    cudaSharedMemBankSizeEightByte = 2,
}
#[repr(i32)]
/// Shared memory carveout configurations
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum cudaSharedCarveout {
    cudaSharedmemCarveoutDefault = -1,
    cudaSharedmemCarveoutMaxShared = 100,
    cudaSharedmemCarveoutMaxL1 = 0,
}
#[repr(i32)]
/// CUDA device compute modes
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum cudaComputeMode {
    ///< Default compute mode (Multiple threads can use ::cudaSetDevice() with this device)
    cudaComputeModeDefault = 0,
    ///< Compute-exclusive-thread mode (Only one thread in one process will be able to use ::cudaSetDevice() with this device)
    cudaComputeModeExclusive = 1,
    ///< Compute-prohibited mode (No threads can use ::cudaSetDevice() with this device)
    cudaComputeModeProhibited = 2,
    ///< Compute-exclusive-process mode (Many threads in one process will be able to use ::cudaSetDevice() with this device)
    cudaComputeModeExclusiveProcess = 3,
}
#[repr(i32)]
/// CUDA Limits
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum cudaLimit {
    ///< GPU thread stack size
    cudaLimitStackSize = 0,
    ///< GPU printf FIFO size
    cudaLimitPrintfFifoSize = 1,
    ///< GPU malloc heap size
    cudaLimitMallocHeapSize = 2,
    ///< GPU device runtime synchronize depth
    cudaLimitDevRuntimeSyncDepth = 3,
    ///< GPU device runtime pending launch count
    cudaLimitDevRuntimePendingLaunchCount = 4,
    ///< A value between 0 and 128 that indicates the maximum fetch granularity of L2 (in Bytes). This is a hint
    cudaLimitMaxL2FetchGranularity = 5,
}
#[repr(i32)]
/// CUDA Memory Advise values
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum cudaMemoryAdvise {
    ///< Data will mostly be read and only occassionally be written to
    cudaMemAdviseSetReadMostly = 1,
    ///< Undo the effect of ::cudaMemAdviseSetReadMostly
    cudaMemAdviseUnsetReadMostly = 2,
    ///< Set the preferred location for the data as the specified device
    cudaMemAdviseSetPreferredLocation = 3,
    ///< Clear the preferred location for the data
    cudaMemAdviseUnsetPreferredLocation = 4,
    ///< Data will be accessed by the specified device, so prevent page faults as much as possible
    cudaMemAdviseSetAccessedBy = 5,
    ///< Let the Unified Memory subsystem decide on the page faulting policy for the specified device
    cudaMemAdviseUnsetAccessedBy = 6,
}
#[repr(i32)]
/// CUDA range attributes
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum cudaMemRangeAttribute {
    ///< Whether the range will mostly be read and only occassionally be written to
    cudaMemRangeAttributeReadMostly = 1,
    ///< The preferred location of the range
    cudaMemRangeAttributePreferredLocation = 2,
    ///< Memory range has ::cudaMemAdviseSetAccessedBy set for specified device
    cudaMemRangeAttributeAccessedBy = 3,
    ///< The last location to which the range was prefetched
    cudaMemRangeAttributeLastPrefetchLocation = 4,
}
#[repr(i32)]
/// CUDA Profiler Output modes
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum cudaOutputMode {
    ///< Output mode Key-Value pair format.
    cudaKeyValuePair = 0,
    ///< Output mode Comma separated values format.
    cudaCSV = 1,
}
#[repr(i32)]
/// CUDA device attributes
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum cudaDeviceAttr {
    ///< Maximum number of threads per block
    cudaDevAttrMaxThreadsPerBlock = 1,
    ///< Maximum block dimension X
    cudaDevAttrMaxBlockDimX = 2,
    ///< Maximum block dimension Y
    cudaDevAttrMaxBlockDimY = 3,
    ///< Maximum block dimension Z
    cudaDevAttrMaxBlockDimZ = 4,
    ///< Maximum grid dimension X
    cudaDevAttrMaxGridDimX = 5,
    ///< Maximum grid dimension Y
    cudaDevAttrMaxGridDimY = 6,
    ///< Maximum grid dimension Z
    cudaDevAttrMaxGridDimZ = 7,
    ///< Maximum shared memory available per block in bytes
    cudaDevAttrMaxSharedMemoryPerBlock = 8,
    ///< Memory available on device for __constant__ variables in a CUDA C kernel in bytes
    cudaDevAttrTotalConstantMemory = 9,
    ///< Warp size in threads
    cudaDevAttrWarpSize = 10,
    ///< Maximum pitch in bytes allowed by memory copies
    cudaDevAttrMaxPitch = 11,
    ///< Maximum number of 32-bit registers available per block
    cudaDevAttrMaxRegistersPerBlock = 12,
    ///< Peak clock frequency in kilohertz
    cudaDevAttrClockRate = 13,
    ///< Alignment requirement for textures
    cudaDevAttrTextureAlignment = 14,
    ///< Device can possibly copy memory and execute a kernel concurrently
    cudaDevAttrGpuOverlap = 15,
    ///< Number of multiprocessors on device
    cudaDevAttrMultiProcessorCount = 16,
    ///< Specifies whether there is a run time limit on kernels
    cudaDevAttrKernelExecTimeout = 17,
    ///< Device is integrated with host memory
    cudaDevAttrIntegrated = 18,
    ///< Device can map host memory into CUDA address space
    cudaDevAttrCanMapHostMemory = 19,
    ///< Compute mode (See ::cudaComputeMode for details)
    cudaDevAttrComputeMode = 20,
    ///< Maximum 1D texture width
    cudaDevAttrMaxTexture1DWidth = 21,
    ///< Maximum 2D texture width
    cudaDevAttrMaxTexture2DWidth = 22,
    ///< Maximum 2D texture height
    cudaDevAttrMaxTexture2DHeight = 23,
    ///< Maximum 3D texture width
    cudaDevAttrMaxTexture3DWidth = 24,
    ///< Maximum 3D texture height
    cudaDevAttrMaxTexture3DHeight = 25,
    ///< Maximum 3D texture depth
    cudaDevAttrMaxTexture3DDepth = 26,
    ///< Maximum 2D layered texture width
    cudaDevAttrMaxTexture2DLayeredWidth = 27,
    ///< Maximum 2D layered texture height
    cudaDevAttrMaxTexture2DLayeredHeight = 28,
    ///< Maximum layers in a 2D layered texture
    cudaDevAttrMaxTexture2DLayeredLayers = 29,
    ///< Alignment requirement for surfaces
    cudaDevAttrSurfaceAlignment = 30,
    ///< Device can possibly execute multiple kernels concurrently
    cudaDevAttrConcurrentKernels = 31,
    ///< Device has ECC support enabled
    cudaDevAttrEccEnabled = 32,
    ///< PCI bus ID of the device
    cudaDevAttrPciBusId = 33,
    ///< PCI device ID of the device
    cudaDevAttrPciDeviceId = 34,
    ///< Device is using TCC driver model
    cudaDevAttrTccDriver = 35,
    ///< Peak memory clock frequency in kilohertz
    cudaDevAttrMemoryClockRate = 36,
    ///< Global memory bus width in bits
    cudaDevAttrGlobalMemoryBusWidth = 37,
    ///< Size of L2 cache in bytes
    cudaDevAttrL2CacheSize = 38,
    ///< Maximum resident threads per multiprocessor
    cudaDevAttrMaxThreadsPerMultiProcessor = 39,
    ///< Number of asynchronous engines
    cudaDevAttrAsyncEngineCount = 40,
    ///< Device shares a unified address space with the host
    cudaDevAttrUnifiedAddressing = 41,
    ///< Maximum 1D layered texture width
    cudaDevAttrMaxTexture1DLayeredWidth = 42,
    ///< Maximum layers in a 1D layered texture
    cudaDevAttrMaxTexture1DLayeredLayers = 43,
    ///< Maximum 2D texture width if cudaArrayTextureGather is set
    cudaDevAttrMaxTexture2DGatherWidth = 45,
    ///< Maximum 2D texture height if cudaArrayTextureGather is set
    cudaDevAttrMaxTexture2DGatherHeight = 46,
    ///< Alternate maximum 3D texture width
    cudaDevAttrMaxTexture3DWidthAlt = 47,
    ///< Alternate maximum 3D texture height
    cudaDevAttrMaxTexture3DHeightAlt = 48,
    ///< Alternate maximum 3D texture depth
    cudaDevAttrMaxTexture3DDepthAlt = 49,
    ///< PCI domain ID of the device
    cudaDevAttrPciDomainId = 50,
    ///< Pitch alignment requirement for textures
    cudaDevAttrTexturePitchAlignment = 51,
    ///< Maximum cubemap texture width/height
    cudaDevAttrMaxTextureCubemapWidth = 52,
    ///< Maximum cubemap layered texture width/height
    cudaDevAttrMaxTextureCubemapLayeredWidth = 53,
    ///< Maximum layers in a cubemap layered texture
    cudaDevAttrMaxTextureCubemapLayeredLayers = 54,
    ///< Maximum 1D surface width
    cudaDevAttrMaxSurface1DWidth = 55,
    ///< Maximum 2D surface width
    cudaDevAttrMaxSurface2DWidth = 56,
    ///< Maximum 2D surface height
    cudaDevAttrMaxSurface2DHeight = 57,
    ///< Maximum 3D surface width
    cudaDevAttrMaxSurface3DWidth = 58,
    ///< Maximum 3D surface height
    cudaDevAttrMaxSurface3DHeight = 59,
    ///< Maximum 3D surface depth
    cudaDevAttrMaxSurface3DDepth = 60,
    ///< Maximum 1D layered surface width
    cudaDevAttrMaxSurface1DLayeredWidth = 61,
    ///< Maximum layers in a 1D layered surface
    cudaDevAttrMaxSurface1DLayeredLayers = 62,
    ///< Maximum 2D layered surface width
    cudaDevAttrMaxSurface2DLayeredWidth = 63,
    ///< Maximum 2D layered surface height
    cudaDevAttrMaxSurface2DLayeredHeight = 64,
    ///< Maximum layers in a 2D layered surface
    cudaDevAttrMaxSurface2DLayeredLayers = 65,
    ///< Maximum cubemap surface width
    cudaDevAttrMaxSurfaceCubemapWidth = 66,
    ///< Maximum cubemap layered surface width
    cudaDevAttrMaxSurfaceCubemapLayeredWidth = 67,
    ///< Maximum layers in a cubemap layered surface
    cudaDevAttrMaxSurfaceCubemapLayeredLayers = 68,
    ///< Maximum 1D linear texture width
    cudaDevAttrMaxTexture1DLinearWidth = 69,
    ///< Maximum 2D linear texture width
    cudaDevAttrMaxTexture2DLinearWidth = 70,
    ///< Maximum 2D linear texture height
    cudaDevAttrMaxTexture2DLinearHeight = 71,
    ///< Maximum 2D linear texture pitch in bytes
    cudaDevAttrMaxTexture2DLinearPitch = 72,
    ///< Maximum mipmapped 2D texture width
    cudaDevAttrMaxTexture2DMipmappedWidth = 73,
    ///< Maximum mipmapped 2D texture height
    cudaDevAttrMaxTexture2DMipmappedHeight = 74,
    ///< Major compute capability version number
    cudaDevAttrComputeCapabilityMajor = 75,
    ///< Minor compute capability version number
    cudaDevAttrComputeCapabilityMinor = 76,
    ///< Maximum mipmapped 1D texture width
    cudaDevAttrMaxTexture1DMipmappedWidth = 77,
    ///< Device supports stream priorities
    cudaDevAttrStreamPrioritiesSupported = 78,
    ///< Device supports caching globals in L1
    cudaDevAttrGlobalL1CacheSupported = 79,
    ///< Device supports caching locals in L1
    cudaDevAttrLocalL1CacheSupported = 80,
    ///< Maximum shared memory available per multiprocessor in bytes
    cudaDevAttrMaxSharedMemoryPerMultiprocessor = 81,
    ///< Maximum number of 32-bit registers available per multiprocessor
    cudaDevAttrMaxRegistersPerMultiprocessor = 82,
    ///< Device can allocate managed memory on this system
    cudaDevAttrManagedMemory = 83,
    ///< Device is on a multi-GPU board
    cudaDevAttrIsMultiGpuBoard = 84,
    ///< Unique identifier for a group of devices on the same multi-GPU board
    cudaDevAttrMultiGpuBoardGroupID = 85,
    ///< Link between the device and the host supports native atomic operations
    cudaDevAttrHostNativeAtomicSupported = 86,
    ///< Ratio of single precision performance (in floating-point operations per second) to double precision performance
    cudaDevAttrSingleToDoublePrecisionPerfRatio = 87,
    ///< Device supports coherently accessing pageable memory without calling cudaHostRegister on it
    cudaDevAttrPageableMemoryAccess = 88,
    ///< Device can coherently access managed memory concurrently with the CPU
    cudaDevAttrConcurrentManagedAccess = 89,
    ///< Device supports Compute Preemption
    cudaDevAttrComputePreemptionSupported = 90,
    ///< Device can access host registered memory at the same virtual address as the CPU
    cudaDevAttrCanUseHostPointerForRegisteredMem = 91,
    cudaDevAttrReserved92 = 92,
    cudaDevAttrReserved93 = 93,
    cudaDevAttrReserved94 = 94,
    ///< Device supports launching cooperative kernels via ::cudaLaunchCooperativeKernel
    cudaDevAttrCooperativeLaunch = 95,
    ///< Device can participate in cooperative kernels launched via ::cudaLaunchCooperativeKernelMultiDevice
    cudaDevAttrCooperativeMultiDeviceLaunch = 96,
    ///< The maximum optin shared memory per block. This value may vary by chip. See ::cudaFuncSetAttribute
    cudaDevAttrMaxSharedMemoryPerBlockOptin = 97,
    ///< Device supports flushing of outstanding remote writes.
    cudaDevAttrCanFlushRemoteWrites = 98,
    ///< Device supports host memory registration via ::cudaHostRegister.
    cudaDevAttrHostRegisterSupported = 99,
    ///< Device accesses pageable memory via the host's page tables.
    cudaDevAttrPageableMemoryAccessUsesHostPageTables = 100,
    ///< Host can directly access managed memory on the device without migration.
    cudaDevAttrDirectManagedMemAccessFromHost = 101,
}
#[repr(i32)]
/// CUDA device P2P attributes
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum cudaDeviceP2PAttr {
    ///< A relative value indicating the performance of the link between two devices
    cudaDevP2PAttrPerformanceRank = 1,
    ///< Peer access is enabled
    cudaDevP2PAttrAccessSupported = 2,
    ///< Native atomic operation over the link supported
    cudaDevP2PAttrNativeAtomicSupported = 3,
    ///< Accessing CUDA arrays over the link supported
    cudaDevP2PAttrCudaArrayAccessSupported = 4,
}
pub type cudaUUID_t = CUuuid_st;
/// CUDA device properties
#[repr(C)]
pub struct cudaDeviceProp {
    ///< ASCII string identifying device
    pub name: [::std::os::raw::c_char; 256usize],
    ///< 16-byte unique identifier
    pub uuid: cudaUUID_t,
    ///< 8-byte locally unique identifier. Value is undefined on TCC and non-Windows platforms
    pub luid: [::std::os::raw::c_char; 8usize],
    ///< LUID device node mask. Value is undefined on TCC and non-Windows platforms
    pub luidDeviceNodeMask: ::std::os::raw::c_uint,
    ///< Global memory available on device in bytes
    pub totalGlobalMem: usize,
    ///< Shared memory available per block in bytes
    pub sharedMemPerBlock: usize,
    ///< 32-bit registers available per block
    pub regsPerBlock: ::std::os::raw::c_int,
    ///< Warp size in threads
    pub warpSize: ::std::os::raw::c_int,
    ///< Maximum pitch in bytes allowed by memory copies
    pub memPitch: usize,
    ///< Maximum number of threads per block
    pub maxThreadsPerBlock: ::std::os::raw::c_int,
    ///< Maximum size of each dimension of a block
    pub maxThreadsDim: [::std::os::raw::c_int; 3usize],
    ///< Maximum size of each dimension of a grid
    pub maxGridSize: [::std::os::raw::c_int; 3usize],
    ///< Clock frequency in kilohertz
    pub clockRate: ::std::os::raw::c_int,
    ///< Constant memory available on device in bytes
    pub totalConstMem: usize,
    ///< Major compute capability
    pub major: ::std::os::raw::c_int,
    ///< Minor compute capability
    pub minor: ::std::os::raw::c_int,
    ///< Alignment requirement for textures
    pub textureAlignment: usize,
    ///< Pitch alignment requirement for texture references bound to pitched memory
    pub texturePitchAlignment: usize,
    ///< Device can concurrently copy memory and execute a kernel. Deprecated. Use instead asyncEngineCount.
    pub deviceOverlap: ::std::os::raw::c_int,
    ///< Number of multiprocessors on device
    pub multiProcessorCount: ::std::os::raw::c_int,
    ///< Specified whether there is a run time limit on kernels
    pub kernelExecTimeoutEnabled: ::std::os::raw::c_int,
    ///< Device is integrated as opposed to discrete
    pub integrated: ::std::os::raw::c_int,
    ///< Device can map host memory with cudaHostAlloc/cudaHostGetDevicePointer
    pub canMapHostMemory: ::std::os::raw::c_int,
    ///< Compute mode (See ::cudaComputeMode)
    pub computeMode: ::std::os::raw::c_int,
    ///< Maximum 1D texture size
    pub maxTexture1D: ::std::os::raw::c_int,
    ///< Maximum 1D mipmapped texture size
    pub maxTexture1DMipmap: ::std::os::raw::c_int,
    ///< Maximum size for 1D textures bound to linear memory
    pub maxTexture1DLinear: ::std::os::raw::c_int,
    ///< Maximum 2D texture dimensions
    pub maxTexture2D: [::std::os::raw::c_int; 2usize],
    ///< Maximum 2D mipmapped texture dimensions
    pub maxTexture2DMipmap: [::std::os::raw::c_int; 2usize],
    ///< Maximum dimensions (width, height, pitch) for 2D textures bound to pitched memory
    pub maxTexture2DLinear: [::std::os::raw::c_int; 3usize],
    ///< Maximum 2D texture dimensions if texture gather operations have to be performed
    pub maxTexture2DGather: [::std::os::raw::c_int; 2usize],
    ///< Maximum 3D texture dimensions
    pub maxTexture3D: [::std::os::raw::c_int; 3usize],
    ///< Maximum alternate 3D texture dimensions
    pub maxTexture3DAlt: [::std::os::raw::c_int; 3usize],
    ///< Maximum Cubemap texture dimensions
    pub maxTextureCubemap: ::std::os::raw::c_int,
    ///< Maximum 1D layered texture dimensions
    pub maxTexture1DLayered: [::std::os::raw::c_int; 2usize],
    ///< Maximum 2D layered texture dimensions
    pub maxTexture2DLayered: [::std::os::raw::c_int; 3usize],
    ///< Maximum Cubemap layered texture dimensions
    pub maxTextureCubemapLayered: [::std::os::raw::c_int; 2usize],
    ///< Maximum 1D surface size
    pub maxSurface1D: ::std::os::raw::c_int,
    ///< Maximum 2D surface dimensions
    pub maxSurface2D: [::std::os::raw::c_int; 2usize],
    ///< Maximum 3D surface dimensions
    pub maxSurface3D: [::std::os::raw::c_int; 3usize],
    ///< Maximum 1D layered surface dimensions
    pub maxSurface1DLayered: [::std::os::raw::c_int; 2usize],
    ///< Maximum 2D layered surface dimensions
    pub maxSurface2DLayered: [::std::os::raw::c_int; 3usize],
    ///< Maximum Cubemap surface dimensions
    pub maxSurfaceCubemap: ::std::os::raw::c_int,
    ///< Maximum Cubemap layered surface dimensions
    pub maxSurfaceCubemapLayered: [::std::os::raw::c_int; 2usize],
    ///< Alignment requirements for surfaces
    pub surfaceAlignment: usize,
    ///< Device can possibly execute multiple kernels concurrently
    pub concurrentKernels: ::std::os::raw::c_int,
    ///< Device has ECC support enabled
    pub ECCEnabled: ::std::os::raw::c_int,
    ///< PCI bus ID of the device
    pub pciBusID: ::std::os::raw::c_int,
    ///< PCI device ID of the device
    pub pciDeviceID: ::std::os::raw::c_int,
    ///< PCI domain ID of the device
    pub pciDomainID: ::std::os::raw::c_int,
    ///< 1 if device is a Tesla device using TCC driver, 0 otherwise
    pub tccDriver: ::std::os::raw::c_int,
    ///< Number of asynchronous engines
    pub asyncEngineCount: ::std::os::raw::c_int,
    ///< Device shares a unified address space with the host
    pub unifiedAddressing: ::std::os::raw::c_int,
    ///< Peak memory clock frequency in kilohertz
    pub memoryClockRate: ::std::os::raw::c_int,
    ///< Global memory bus width in bits
    pub memoryBusWidth: ::std::os::raw::c_int,
    ///< Size of L2 cache in bytes
    pub l2CacheSize: ::std::os::raw::c_int,
    ///< Maximum resident threads per multiprocessor
    pub maxThreadsPerMultiProcessor: ::std::os::raw::c_int,
    ///< Device supports stream priorities
    pub streamPrioritiesSupported: ::std::os::raw::c_int,
    ///< Device supports caching globals in L1
    pub globalL1CacheSupported: ::std::os::raw::c_int,
    ///< Device supports caching locals in L1
    pub localL1CacheSupported: ::std::os::raw::c_int,
    ///< Shared memory available per multiprocessor in bytes
    pub sharedMemPerMultiprocessor: usize,
    ///< 32-bit registers available per multiprocessor
    pub regsPerMultiprocessor: ::std::os::raw::c_int,
    ///< Device supports allocating managed memory on this system
    pub managedMemory: ::std::os::raw::c_int,
    ///< Device is on a multi-GPU board
    pub isMultiGpuBoard: ::std::os::raw::c_int,
    ///< Unique identifier for a group of devices on the same multi-GPU board
    pub multiGpuBoardGroupID: ::std::os::raw::c_int,
    ///< Link between the device and the host supports native atomic operations
    pub hostNativeAtomicSupported: ::std::os::raw::c_int,
    ///< Ratio of single precision performance (in floating-point operations per second) to double precision performance
    pub singleToDoublePrecisionPerfRatio: ::std::os::raw::c_int,
    ///< Device supports coherently accessing pageable memory without calling cudaHostRegister on it
    pub pageableMemoryAccess: ::std::os::raw::c_int,
    ///< Device can coherently access managed memory concurrently with the CPU
    pub concurrentManagedAccess: ::std::os::raw::c_int,
    ///< Device supports Compute Preemption
    pub computePreemptionSupported: ::std::os::raw::c_int,
    ///< Device can access host registered memory at the same virtual address as the CPU
    pub canUseHostPointerForRegisteredMem: ::std::os::raw::c_int,
    ///< Device supports launching cooperative kernels via ::cudaLaunchCooperativeKernel
    pub cooperativeLaunch: ::std::os::raw::c_int,
    ///< Device can participate in cooperative kernels launched via ::cudaLaunchCooperativeKernelMultiDevice
    pub cooperativeMultiDeviceLaunch: ::std::os::raw::c_int,
    ///< Per device maximum shared memory per block usable by special opt in
    pub sharedMemPerBlockOptin: usize,
    ///< Device accesses pageable memory via the host's page tables
    pub pageableMemoryAccessUsesHostPageTables: ::std::os::raw::c_int,
    ///< Host can directly access managed memory on the device without migration.
    pub directManagedMemAccessFromHost: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cudaDeviceProp() {
    assert_eq!(
        ::std::mem::size_of::<cudaDeviceProp>(),
        712usize,
        concat!("Size of: ", stringify!(cudaDeviceProp))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaDeviceProp>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaDeviceProp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).uuid as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).luid as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(luid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).luidDeviceNodeMask as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(luidDeviceNodeMask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).totalGlobalMem as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(totalGlobalMem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).sharedMemPerBlock as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(sharedMemPerBlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).regsPerBlock as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(regsPerBlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).warpSize as *const _ as usize },
        308usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(warpSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).memPitch as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(memPitch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).maxThreadsPerBlock as *const _ as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxThreadsPerBlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).maxThreadsDim as *const _ as usize },
        324usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxThreadsDim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).maxGridSize as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxGridSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).clockRate as *const _ as usize },
        348usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(clockRate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).totalConstMem as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(totalConstMem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).major as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(major)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).minor as *const _ as usize },
        364usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(minor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).textureAlignment as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(textureAlignment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).texturePitchAlignment as *const _ as usize
        },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(texturePitchAlignment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).deviceOverlap as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(deviceOverlap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).multiProcessorCount as *const _ as usize
        },
        388usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(multiProcessorCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).kernelExecTimeoutEnabled as *const _ as usize
        },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(kernelExecTimeoutEnabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).integrated as *const _ as usize },
        396usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(integrated)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).canMapHostMemory as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(canMapHostMemory)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).computeMode as *const _ as usize },
        404usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(computeMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).maxTexture1D as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxTexture1D)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).maxTexture1DMipmap as *const _ as usize
        },
        412usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxTexture1DMipmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).maxTexture1DLinear as *const _ as usize
        },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxTexture1DLinear)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).maxTexture2D as *const _ as usize },
        420usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxTexture2D)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).maxTexture2DMipmap as *const _ as usize
        },
        428usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxTexture2DMipmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).maxTexture2DLinear as *const _ as usize
        },
        436usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxTexture2DLinear)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).maxTexture2DGather as *const _ as usize
        },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxTexture2DGather)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).maxTexture3D as *const _ as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxTexture3D)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).maxTexture3DAlt as *const _ as usize },
        468usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxTexture3DAlt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).maxTextureCubemap as *const _ as usize
        },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxTextureCubemap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).maxTexture1DLayered as *const _ as usize
        },
        484usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxTexture1DLayered)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).maxTexture2DLayered as *const _ as usize
        },
        492usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxTexture2DLayered)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).maxTextureCubemapLayered as *const _ as usize
        },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxTextureCubemapLayered)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).maxSurface1D as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxSurface1D)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).maxSurface2D as *const _ as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxSurface2D)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).maxSurface3D as *const _ as usize },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxSurface3D)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).maxSurface1DLayered as *const _ as usize
        },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxSurface1DLayered)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).maxSurface2DLayered as *const _ as usize
        },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxSurface2DLayered)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).maxSurfaceCubemap as *const _ as usize
        },
        556usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxSurfaceCubemap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).maxSurfaceCubemapLayered as *const _ as usize
        },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxSurfaceCubemapLayered)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).surfaceAlignment as *const _ as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(surfaceAlignment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).concurrentKernels as *const _ as usize
        },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(concurrentKernels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).ECCEnabled as *const _ as usize },
        580usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(ECCEnabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).pciBusID as *const _ as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(pciBusID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).pciDeviceID as *const _ as usize },
        588usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(pciDeviceID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).pciDomainID as *const _ as usize },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(pciDomainID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).tccDriver as *const _ as usize },
        596usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(tccDriver)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).asyncEngineCount as *const _ as usize },
        600usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(asyncEngineCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).unifiedAddressing as *const _ as usize
        },
        604usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(unifiedAddressing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).memoryClockRate as *const _ as usize },
        608usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(memoryClockRate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).memoryBusWidth as *const _ as usize },
        612usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(memoryBusWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).l2CacheSize as *const _ as usize },
        616usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(l2CacheSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).maxThreadsPerMultiProcessor as *const _
                as usize
        },
        620usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxThreadsPerMultiProcessor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).streamPrioritiesSupported as *const _
                as usize
        },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(streamPrioritiesSupported)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).globalL1CacheSupported as *const _ as usize
        },
        628usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(globalL1CacheSupported)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).localL1CacheSupported as *const _ as usize
        },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(localL1CacheSupported)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).sharedMemPerMultiprocessor as *const _
                as usize
        },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(sharedMemPerMultiprocessor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).regsPerMultiprocessor as *const _ as usize
        },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(regsPerMultiprocessor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).managedMemory as *const _ as usize },
        652usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(managedMemory)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).isMultiGpuBoard as *const _ as usize },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(isMultiGpuBoard)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).multiGpuBoardGroupID as *const _ as usize
        },
        660usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(multiGpuBoardGroupID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).hostNativeAtomicSupported as *const _
                as usize
        },
        664usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(hostNativeAtomicSupported)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).singleToDoublePrecisionPerfRatio as *const _
                as usize
        },
        668usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(singleToDoublePrecisionPerfRatio)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).pageableMemoryAccess as *const _ as usize
        },
        672usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(pageableMemoryAccess)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).concurrentManagedAccess as *const _ as usize
        },
        676usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(concurrentManagedAccess)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).computePreemptionSupported as *const _
                as usize
        },
        680usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(computePreemptionSupported)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).canUseHostPointerForRegisteredMem as *const _
                as usize
        },
        684usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(canUseHostPointerForRegisteredMem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).cooperativeLaunch as *const _ as usize
        },
        688usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(cooperativeLaunch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).cooperativeMultiDeviceLaunch as *const _
                as usize
        },
        692usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(cooperativeMultiDeviceLaunch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).sharedMemPerBlockOptin as *const _ as usize
        },
        696usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(sharedMemPerBlockOptin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).pageableMemoryAccessUsesHostPageTables
                as *const _ as usize
        },
        704usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(pageableMemoryAccessUsesHostPageTables)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).directManagedMemAccessFromHost as *const _
                as usize
        },
        708usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(directManagedMemAccessFromHost)
        )
    );
}
/// CUDA IPC event handle
#[repr(C)]
pub struct cudaIpcEventHandle_st {
    pub reserved: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_cudaIpcEventHandle_st() {
    assert_eq!(
        ::std::mem::size_of::<cudaIpcEventHandle_st>(),
        64usize,
        concat!("Size of: ", stringify!(cudaIpcEventHandle_st))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaIpcEventHandle_st>(),
        1usize,
        concat!("Alignment of ", stringify!(cudaIpcEventHandle_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaIpcEventHandle_st>())).reserved as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaIpcEventHandle_st),
            "::",
            stringify!(reserved)
        )
    );
}
pub type cudaIpcEventHandle_t = cudaIpcEventHandle_st;
/// CUDA IPC memory handle
#[repr(C)]
pub struct cudaIpcMemHandle_st {
    pub reserved: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_cudaIpcMemHandle_st() {
    assert_eq!(
        ::std::mem::size_of::<cudaIpcMemHandle_st>(),
        64usize,
        concat!("Size of: ", stringify!(cudaIpcMemHandle_st))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaIpcMemHandle_st>(),
        1usize,
        concat!("Alignment of ", stringify!(cudaIpcMemHandle_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaIpcMemHandle_st>())).reserved as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaIpcMemHandle_st),
            "::",
            stringify!(reserved)
        )
    );
}
pub type cudaIpcMemHandle_t = cudaIpcMemHandle_st;
#[repr(i32)]
/// External memory handle types
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum cudaExternalMemoryHandleType {
    /// Handle is an opaque file descriptor
    cudaExternalMemoryHandleTypeOpaqueFd = 1,
    /// Handle is an opaque shared NT handle
    cudaExternalMemoryHandleTypeOpaqueWin32 = 2,
    /// Handle is an opaque, globally shared handle
    cudaExternalMemoryHandleTypeOpaqueWin32Kmt = 3,
    /// Handle is a D3D12 heap object
    cudaExternalMemoryHandleTypeD3D12Heap = 4,
    /// Handle is a D3D12 committed resource
    cudaExternalMemoryHandleTypeD3D12Resource = 5,
}
/// External memory handle descriptor
#[repr(C)]
pub struct cudaExternalMemoryHandleDesc {
    /// Type of the handle
    pub type_: cudaExternalMemoryHandleType,
    pub handle: cudaExternalMemoryHandleDesc__bindgen_ty_1,
    /// Size of the memory allocation
    pub size: ::std::os::raw::c_ulonglong,
    /// Flags must either be zero or ::cudaExternalMemoryDedicated
    pub flags: ::std::os::raw::c_uint,
}
#[repr(C)]
pub union cudaExternalMemoryHandleDesc__bindgen_ty_1 {
    /// File descriptor referencing the memory object. Valid
    /// when type is
    /// ::cudaExternalMemoryHandleTypeOpaqueFd
    pub fd: ::std::os::raw::c_int,
    pub win32: cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u64; 2usize],
}
/// Win32 handle referencing the semaphore object. Valid when
/// type is one of the following:
/// - ::cudaExternalMemoryHandleTypeOpaqueWin32
/// - ::cudaExternalMemoryHandleTypeOpaqueWin32Kmt
/// - ::cudaExternalMemoryHandleTypeD3D12Heap
/// - ::cudaExternalMemoryHandleTypeD3D12Resource
/// Exactly one of 'handle' and 'name' must be non-NULL. If
/// type is ::cudaExternalMemoryHandleTypeOpaqueWin32Kmt
/// then 'name' must be NULL.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1 {
    /// Valid NT handle. Must be NULL if 'name' is non-NULL
    pub handle: *mut ::std::os::raw::c_void,
    /// Name of a valid memory object.
    /// Must be NULL if 'handle' is non-NULL.
    pub name: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1>()))
                .handle as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1>()))
                .name as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(name)
        )
    );
}
#[test]
fn bindgen_test_layout_cudaExternalMemoryHandleDesc__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalMemoryHandleDesc__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalMemoryHandleDesc__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalMemoryHandleDesc__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalMemoryHandleDesc__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalMemoryHandleDesc__bindgen_ty_1>())).fd as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalMemoryHandleDesc__bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalMemoryHandleDesc__bindgen_ty_1>())).win32 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalMemoryHandleDesc__bindgen_ty_1),
            "::",
            stringify!(win32)
        )
    );
}
#[test]
fn bindgen_test_layout_cudaExternalMemoryHandleDesc() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalMemoryHandleDesc>(),
        40usize,
        concat!("Size of: ", stringify!(cudaExternalMemoryHandleDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalMemoryHandleDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaExternalMemoryHandleDesc))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalMemoryHandleDesc>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalMemoryHandleDesc),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalMemoryHandleDesc>())).handle as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalMemoryHandleDesc),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalMemoryHandleDesc>())).size as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalMemoryHandleDesc),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalMemoryHandleDesc>())).flags as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalMemoryHandleDesc),
            "::",
            stringify!(flags)
        )
    );
}
/// External memory buffer descriptor
#[repr(C)]
pub struct cudaExternalMemoryBufferDesc {
    /// Offset into the memory object where the buffer's base is
    pub offset: ::std::os::raw::c_ulonglong,
    /// Size of the buffer
    pub size: ::std::os::raw::c_ulonglong,
    /// Flags reserved for future use. Must be zero.
    pub flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_cudaExternalMemoryBufferDesc() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalMemoryBufferDesc>(),
        24usize,
        concat!("Size of: ", stringify!(cudaExternalMemoryBufferDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalMemoryBufferDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaExternalMemoryBufferDesc))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalMemoryBufferDesc>())).offset as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalMemoryBufferDesc),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalMemoryBufferDesc>())).size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalMemoryBufferDesc),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalMemoryBufferDesc>())).flags as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalMemoryBufferDesc),
            "::",
            stringify!(flags)
        )
    );
}
/// External memory mipmap descriptor
#[repr(C)]
pub struct cudaExternalMemoryMipmappedArrayDesc {
    /// Offset into the memory object where the base level of the
    /// mipmap chain is.
    pub offset: ::std::os::raw::c_ulonglong,
    /// Format of base level of the mipmap chain
    pub formatDesc: cudaChannelFormatDesc,
    /// Dimensions of base level of the mipmap chain
    pub extent: cudaExtent,
    /// Flags associated with CUDA mipmapped arrays.
    /// See ::cudaMallocMipmappedArray
    pub flags: ::std::os::raw::c_uint,
    /// Total number of levels in the mipmap chain
    pub numLevels: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_cudaExternalMemoryMipmappedArrayDesc() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalMemoryMipmappedArrayDesc>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalMemoryMipmappedArrayDesc)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalMemoryMipmappedArrayDesc>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalMemoryMipmappedArrayDesc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalMemoryMipmappedArrayDesc>())).offset as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalMemoryMipmappedArrayDesc),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalMemoryMipmappedArrayDesc>())).formatDesc as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalMemoryMipmappedArrayDesc),
            "::",
            stringify!(formatDesc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalMemoryMipmappedArrayDesc>())).extent as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalMemoryMipmappedArrayDesc),
            "::",
            stringify!(extent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalMemoryMipmappedArrayDesc>())).flags as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalMemoryMipmappedArrayDesc),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalMemoryMipmappedArrayDesc>())).numLevels as *const _
                as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalMemoryMipmappedArrayDesc),
            "::",
            stringify!(numLevels)
        )
    );
}
#[repr(i32)]
/// External semaphore handle types
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum cudaExternalSemaphoreHandleType {
    /// Handle is an opaque file descriptor
    cudaExternalSemaphoreHandleTypeOpaqueFd = 1,
    /// Handle is an opaque shared NT handle
    cudaExternalSemaphoreHandleTypeOpaqueWin32 = 2,
    /// Handle is an opaque, globally shared handle
    cudaExternalSemaphoreHandleTypeOpaqueWin32Kmt = 3,
    /// Handle is a shared NT handle referencing a D3D12 fence object
    cudaExternalSemaphoreHandleTypeD3D12Fence = 4,
}
/// External semaphore handle descriptor
#[repr(C)]
pub struct cudaExternalSemaphoreHandleDesc {
    /// Type of the handle
    pub type_: cudaExternalSemaphoreHandleType,
    pub handle: cudaExternalSemaphoreHandleDesc__bindgen_ty_1,
    /// Flags reserved for the future. Must be zero.
    pub flags: ::std::os::raw::c_uint,
}
#[repr(C)]
pub union cudaExternalSemaphoreHandleDesc__bindgen_ty_1 {
    /// File descriptor referencing the semaphore object. Valid
    /// when type is ::cudaExternalSemaphoreHandleTypeOpaqueFd
    pub fd: ::std::os::raw::c_int,
    pub win32: cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u64; 2usize],
}
/// Win32 handle referencing the semaphore object. Valid when
/// type is one of the following:
/// - ::cudaExternalSemaphoreHandleTypeOpaqueWin32
/// - ::cudaExternalSemaphoreHandleTypeOpaqueWin32Kmt
/// - ::cudaExternalSemaphoreHandleTypeD3D12Fence
/// Exactly one of 'handle' and 'name' must be non-NULL. If
/// type is ::cudaExternalSemaphoreHandleTypeOpaqueWin32Kmt
/// then 'name' must be NULL.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1 {
    /// Valid NT handle. Must be NULL if 'name' is non-NULL
    pub handle: *mut ::std::os::raw::c_void,
    /// Name of a valid synchronization primitive.
    /// Must be NULL if 'handle' is non-NULL.
    pub name: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1>()))
                .handle as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1>()))
                .name as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(name)
        )
    );
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreHandleDesc__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreHandleDesc__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreHandleDesc__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalSemaphoreHandleDesc__bindgen_ty_1>())).fd as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalSemaphoreHandleDesc__bindgen_ty_1>())).win32
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1),
            "::",
            stringify!(win32)
        )
    );
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreHandleDesc() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreHandleDesc>(),
        32usize,
        concat!("Size of: ", stringify!(cudaExternalSemaphoreHandleDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreHandleDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaExternalSemaphoreHandleDesc))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalSemaphoreHandleDesc>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreHandleDesc),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalSemaphoreHandleDesc>())).handle as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreHandleDesc),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalSemaphoreHandleDesc>())).flags as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreHandleDesc),
            "::",
            stringify!(flags)
        )
    );
}
/// External semaphore  signal parameters
#[repr(C)]
pub struct cudaExternalSemaphoreSignalParams {
    pub params: cudaExternalSemaphoreSignalParams__bindgen_ty_1,
    /// Flags reserved for the future. Must be zero.
    pub flags: ::std::os::raw::c_uint,
}
#[repr(C)]
pub struct cudaExternalSemaphoreSignalParams__bindgen_ty_1 {
    pub fence: __BindgenUnionField<cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: u64,
}
/// Parameters for fence objects
#[repr(C)]
pub struct cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1 {
    /// Value of fence to be signaled
    pub value: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1>(
            )))
            .value as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(value)
        )
    );
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreSignalParams__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreSignalParams__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreSignalParams__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalSemaphoreSignalParams__bindgen_ty_1>())).fence
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1),
            "::",
            stringify!(fence)
        )
    );
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreSignalParams() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreSignalParams>(),
        16usize,
        concat!("Size of: ", stringify!(cudaExternalSemaphoreSignalParams))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreSignalParams>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreSignalParams)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalSemaphoreSignalParams>())).params as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreSignalParams),
            "::",
            stringify!(params)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalSemaphoreSignalParams>())).flags as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreSignalParams),
            "::",
            stringify!(flags)
        )
    );
}
/// External semaphore wait parameters
#[repr(C)]
pub struct cudaExternalSemaphoreWaitParams {
    pub params: cudaExternalSemaphoreWaitParams__bindgen_ty_1,
    /// Flags reserved for the future. Must be zero.
    pub flags: ::std::os::raw::c_uint,
}
#[repr(C)]
pub struct cudaExternalSemaphoreWaitParams__bindgen_ty_1 {
    pub fence: __BindgenUnionField<cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: u64,
}
/// Parameters for fence objects
#[repr(C)]
pub struct cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1 {
    /// Value of fence to be waited on
    pub value: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1>()))
                .value as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(value)
        )
    );
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreWaitParams__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreWaitParams__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreWaitParams__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalSemaphoreWaitParams__bindgen_ty_1>())).fence
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1),
            "::",
            stringify!(fence)
        )
    );
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreWaitParams() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreWaitParams>(),
        16usize,
        concat!("Size of: ", stringify!(cudaExternalSemaphoreWaitParams))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreWaitParams>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaExternalSemaphoreWaitParams))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalSemaphoreWaitParams>())).params as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreWaitParams),
            "::",
            stringify!(params)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalSemaphoreWaitParams>())).flags as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreWaitParams),
            "::",
            stringify!(flags)
        )
    );
}
/// CUDA Error types
pub use self::cudaError as cudaError_t;
/// CUDA stream
pub type cudaStream_t = *mut CUstream_st;
/// CUDA event types
pub type cudaEvent_t = *mut CUevent_st;
/// CUDA graphics resource types
pub type cudaGraphicsResource_t = *mut cudaGraphicsResource;
/// CUDA output file modes
pub use self::cudaOutputMode as cudaOutputMode_t;
/// CUDA external memory
pub type cudaExternalMemory_t = *mut CUexternalMemory_st;
/// CUDA external semaphore
pub type cudaExternalSemaphore_t = *mut CUexternalSemaphore_st;
/// CUDA graph
pub type cudaGraph_t = *mut CUgraph_st;
/// CUDA graph node.
pub type cudaGraphNode_t = *mut CUgraphNode_st;
#[repr(i32)]
/// CUDA cooperative group scope
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum cudaCGScope {
    ///< Invalid cooperative group scope
    cudaCGScopeInvalid = 0,
    ///< Scope represented by a grid_group
    cudaCGScopeGrid = 1,
    ///< Scope represented by a multi_grid_group
    cudaCGScopeMultiGrid = 2,
}
/// CUDA launch parameters
#[repr(C)]
pub struct cudaLaunchParams {
    ///< Device function symbol
    pub func: *mut ::std::os::raw::c_void,
    ///< Grid dimentions
    pub gridDim: dim3,
    ///< Block dimentions
    pub blockDim: dim3,
    ///< Arguments
    pub args: *mut *mut ::std::os::raw::c_void,
    ///< Shared memory
    pub sharedMem: usize,
    ///< Stream identifier
    pub stream: cudaStream_t,
}
#[test]
fn bindgen_test_layout_cudaLaunchParams() {
    assert_eq!(
        ::std::mem::size_of::<cudaLaunchParams>(),
        56usize,
        concat!("Size of: ", stringify!(cudaLaunchParams))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaLaunchParams>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaLaunchParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaLaunchParams>())).func as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaLaunchParams),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaLaunchParams>())).gridDim as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaLaunchParams),
            "::",
            stringify!(gridDim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaLaunchParams>())).blockDim as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaLaunchParams),
            "::",
            stringify!(blockDim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaLaunchParams>())).args as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaLaunchParams),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaLaunchParams>())).sharedMem as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaLaunchParams),
            "::",
            stringify!(sharedMem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaLaunchParams>())).stream as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaLaunchParams),
            "::",
            stringify!(stream)
        )
    );
}
/// CUDA GPU kernel node parameters
#[repr(C)]
pub struct cudaKernelNodeParams {
    ///< Kernel to launch
    pub func: *mut ::std::os::raw::c_void,
    ///< Grid dimensions
    pub gridDim: dim3,
    ///< Block dimensions
    pub blockDim: dim3,
    ///< Dynamic shared-memory size per thread block in bytes
    pub sharedMemBytes: ::std::os::raw::c_uint,
    ///< Array of pointers to individual kernel arguments
    pub kernelParams: *mut *mut ::std::os::raw::c_void,
    ///< Pointer to kernel arguments in the "extra" format
    pub extra: *mut *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_cudaKernelNodeParams() {
    assert_eq!(
        ::std::mem::size_of::<cudaKernelNodeParams>(),
        56usize,
        concat!("Size of: ", stringify!(cudaKernelNodeParams))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaKernelNodeParams>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaKernelNodeParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaKernelNodeParams>())).func as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaKernelNodeParams),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaKernelNodeParams>())).gridDim as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaKernelNodeParams),
            "::",
            stringify!(gridDim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaKernelNodeParams>())).blockDim as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaKernelNodeParams),
            "::",
            stringify!(blockDim)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaKernelNodeParams>())).sharedMemBytes as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaKernelNodeParams),
            "::",
            stringify!(sharedMemBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaKernelNodeParams>())).kernelParams as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaKernelNodeParams),
            "::",
            stringify!(kernelParams)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaKernelNodeParams>())).extra as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaKernelNodeParams),
            "::",
            stringify!(extra)
        )
    );
}
#[repr(i32)]
/// CUDA Graph node types
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum cudaGraphNodeType {
    ///< GPU kernel node
    cudaGraphNodeTypeKernel = 0,
    ///< Memcpy node
    cudaGraphNodeTypeMemcpy = 1,
    ///< Memset node
    cudaGraphNodeTypeMemset = 2,
    ///< Host (executable) node
    cudaGraphNodeTypeHost = 3,
    ///< Node which executes an embedded graph
    cudaGraphNodeTypeGraph = 4,
    ///< Empty (no-op) node
    cudaGraphNodeTypeEmpty = 5,
    cudaGraphNodeTypeCount = 6,
}
/// CUDA executable (launchable) graph
pub type cudaGraphExec_t = *mut CUgraphExec_st;
#[repr(i32)]
/// CUDA Surface boundary modes
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum cudaSurfaceBoundaryMode {
    ///< Zero boundary mode
    cudaBoundaryModeZero = 0,
    ///< Clamp boundary mode
    cudaBoundaryModeClamp = 1,
    ///< Trap boundary mode
    cudaBoundaryModeTrap = 2,
}
#[repr(i32)]
/// CUDA Surface format modes
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum cudaSurfaceFormatMode {
    ///< Forced format mode
    cudaFormatModeForced = 0,
    ///< Auto format mode
    cudaFormatModeAuto = 1,
}
/// CUDA Surface reference
#[repr(C)]
pub struct surfaceReference {
    /// Channel descriptor for surface reference
    pub channelDesc: cudaChannelFormatDesc,
}
#[test]
fn bindgen_test_layout_surfaceReference() {
    assert_eq!(
        ::std::mem::size_of::<surfaceReference>(),
        20usize,
        concat!("Size of: ", stringify!(surfaceReference))
    );
    assert_eq!(
        ::std::mem::align_of::<surfaceReference>(),
        4usize,
        concat!("Alignment of ", stringify!(surfaceReference))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<surfaceReference>())).channelDesc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(surfaceReference),
            "::",
            stringify!(channelDesc)
        )
    );
}
/// An opaque value that represents a CUDA Surface object
pub type cudaSurfaceObject_t = ::std::os::raw::c_ulonglong;
#[repr(i32)]
/// CUDA texture address modes
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum cudaTextureAddressMode {
    ///< Wrapping address mode
    cudaAddressModeWrap = 0,
    ///< Clamp to edge address mode
    cudaAddressModeClamp = 1,
    ///< Mirror address mode
    cudaAddressModeMirror = 2,
    ///< Border address mode
    cudaAddressModeBorder = 3,
}
#[repr(i32)]
/// CUDA texture filter modes
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum cudaTextureFilterMode {
    ///< Point filter mode
    cudaFilterModePoint = 0,
    ///< Linear filter mode
    cudaFilterModeLinear = 1,
}
#[repr(i32)]
/// CUDA texture read modes
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum cudaTextureReadMode {
    ///< Read texture as specified element type
    cudaReadModeElementType = 0,
    ///< Read texture as normalized float
    cudaReadModeNormalizedFloat = 1,
}
/// CUDA texture reference
#[repr(C)]
pub struct textureReference {
    /// Indicates whether texture reads are normalized or not
    pub normalized: ::std::os::raw::c_int,
    /// Texture filter mode
    pub filterMode: cudaTextureFilterMode,
    /// Texture address mode for up to 3 dimensions
    pub addressMode: [cudaTextureAddressMode; 3usize],
    /// Channel descriptor for the texture reference
    pub channelDesc: cudaChannelFormatDesc,
    /// Perform sRGB->linear conversion during texture read
    pub sRGB: ::std::os::raw::c_int,
    /// Limit to the anisotropy ratio
    pub maxAnisotropy: ::std::os::raw::c_uint,
    /// Mipmap filter mode
    pub mipmapFilterMode: cudaTextureFilterMode,
    /// Offset applied to the supplied mipmap level
    pub mipmapLevelBias: f32,
    /// Lower end of the mipmap level range to clamp access to
    pub minMipmapLevelClamp: f32,
    /// Upper end of the mipmap level range to clamp access to
    pub maxMipmapLevelClamp: f32,
    pub __cudaReserved: [::std::os::raw::c_int; 15usize],
}
#[test]
fn bindgen_test_layout_textureReference() {
    assert_eq!(
        ::std::mem::size_of::<textureReference>(),
        124usize,
        concat!("Size of: ", stringify!(textureReference))
    );
    assert_eq!(
        ::std::mem::align_of::<textureReference>(),
        4usize,
        concat!("Alignment of ", stringify!(textureReference))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<textureReference>())).normalized as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(textureReference),
            "::",
            stringify!(normalized)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<textureReference>())).filterMode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(textureReference),
            "::",
            stringify!(filterMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<textureReference>())).addressMode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(textureReference),
            "::",
            stringify!(addressMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<textureReference>())).channelDesc as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(textureReference),
            "::",
            stringify!(channelDesc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<textureReference>())).sRGB as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(textureReference),
            "::",
            stringify!(sRGB)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<textureReference>())).maxAnisotropy as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(textureReference),
            "::",
            stringify!(maxAnisotropy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<textureReference>())).mipmapFilterMode as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(textureReference),
            "::",
            stringify!(mipmapFilterMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<textureReference>())).mipmapLevelBias as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(textureReference),
            "::",
            stringify!(mipmapLevelBias)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<textureReference>())).minMipmapLevelClamp as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(textureReference),
            "::",
            stringify!(minMipmapLevelClamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<textureReference>())).maxMipmapLevelClamp as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(textureReference),
            "::",
            stringify!(maxMipmapLevelClamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<textureReference>())).__cudaReserved as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(textureReference),
            "::",
            stringify!(__cudaReserved)
        )
    );
}
/// CUDA texture descriptor
#[repr(C)]
pub struct cudaTextureDesc {
    /// Texture address mode for up to 3 dimensions
    pub addressMode: [cudaTextureAddressMode; 3usize],
    /// Texture filter mode
    pub filterMode: cudaTextureFilterMode,
    /// Texture read mode
    pub readMode: cudaTextureReadMode,
    /// Perform sRGB->linear conversion during texture read
    pub sRGB: ::std::os::raw::c_int,
    /// Texture Border Color
    pub borderColor: [f32; 4usize],
    /// Indicates whether texture reads are normalized or not
    pub normalizedCoords: ::std::os::raw::c_int,
    /// Limit to the anisotropy ratio
    pub maxAnisotropy: ::std::os::raw::c_uint,
    /// Mipmap filter mode
    pub mipmapFilterMode: cudaTextureFilterMode,
    /// Offset applied to the supplied mipmap level
    pub mipmapLevelBias: f32,
    /// Lower end of the mipmap level range to clamp access to
    pub minMipmapLevelClamp: f32,
    /// Upper end of the mipmap level range to clamp access to
    pub maxMipmapLevelClamp: f32,
}
#[test]
fn bindgen_test_layout_cudaTextureDesc() {
    assert_eq!(
        ::std::mem::size_of::<cudaTextureDesc>(),
        64usize,
        concat!("Size of: ", stringify!(cudaTextureDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaTextureDesc>(),
        4usize,
        concat!("Alignment of ", stringify!(cudaTextureDesc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaTextureDesc>())).addressMode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaTextureDesc),
            "::",
            stringify!(addressMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaTextureDesc>())).filterMode as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaTextureDesc),
            "::",
            stringify!(filterMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaTextureDesc>())).readMode as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaTextureDesc),
            "::",
            stringify!(readMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaTextureDesc>())).sRGB as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaTextureDesc),
            "::",
            stringify!(sRGB)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaTextureDesc>())).borderColor as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaTextureDesc),
            "::",
            stringify!(borderColor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaTextureDesc>())).normalizedCoords as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaTextureDesc),
            "::",
            stringify!(normalizedCoords)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaTextureDesc>())).maxAnisotropy as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaTextureDesc),
            "::",
            stringify!(maxAnisotropy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaTextureDesc>())).mipmapFilterMode as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaTextureDesc),
            "::",
            stringify!(mipmapFilterMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaTextureDesc>())).mipmapLevelBias as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaTextureDesc),
            "::",
            stringify!(mipmapLevelBias)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaTextureDesc>())).minMipmapLevelClamp as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaTextureDesc),
            "::",
            stringify!(minMipmapLevelClamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaTextureDesc>())).maxMipmapLevelClamp as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaTextureDesc),
            "::",
            stringify!(maxMipmapLevelClamp)
        )
    );
}
/// An opaque value that represents a CUDA texture object
pub type cudaTextureObject_t = ::std::os::raw::c_ulonglong;
/// Type of stream callback functions.
/// \param stream The stream as passed to ::cudaStreamAddCallback, may be NULL.
/// \param status ::cudaSuccess or any persistent error on the stream.
/// \param userData User parameter provided at registration.
pub type cudaStreamCallback_t = ::std::option::Option<
    unsafe extern "C" fn(
        stream: cudaStream_t,
        status: cudaError_t,
        userData: *mut ::std::os::raw::c_void,
    ),
>;
