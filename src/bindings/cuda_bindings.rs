/* automatically generated by rust-bindgen */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub const CUDA_VERSION: u32 = 10000;
pub const CU_IPC_HANDLE_SIZE: u32 = 64;
pub const CU_MEMHOSTALLOC_PORTABLE: u32 = 1;
pub const CU_MEMHOSTALLOC_DEVICEMAP: u32 = 2;
pub const CU_MEMHOSTALLOC_WRITECOMBINED: u32 = 4;
pub const CU_MEMHOSTREGISTER_PORTABLE: u32 = 1;
pub const CU_MEMHOSTREGISTER_DEVICEMAP: u32 = 2;
pub const CU_MEMHOSTREGISTER_IOMEMORY: u32 = 4;
pub const CUDA_EXTERNAL_MEMORY_DEDICATED: u32 = 1;
pub const CUDA_COOPERATIVE_LAUNCH_MULTI_DEVICE_NO_PRE_LAUNCH_SYNC: u32 = 1;
pub const CUDA_COOPERATIVE_LAUNCH_MULTI_DEVICE_NO_POST_LAUNCH_SYNC: u32 = 2;
pub const CUDA_ARRAY3D_LAYERED: u32 = 1;
pub const CUDA_ARRAY3D_2DARRAY: u32 = 1;
pub const CUDA_ARRAY3D_SURFACE_LDST: u32 = 2;
pub const CUDA_ARRAY3D_CUBEMAP: u32 = 4;
pub const CUDA_ARRAY3D_TEXTURE_GATHER: u32 = 8;
pub const CUDA_ARRAY3D_DEPTH_TEXTURE: u32 = 16;
pub const CUDA_ARRAY3D_COLOR_ATTACHMENT: u32 = 32;
pub const CU_TRSA_OVERRIDE_FORMAT: u32 = 1;
pub const CU_TRSF_READ_AS_INTEGER: u32 = 1;
pub const CU_TRSF_NORMALIZED_COORDINATES: u32 = 2;
pub const CU_TRSF_SRGB: u32 = 16;
pub const CU_PARAM_TR_DEFAULT: i32 = -1;
pub type cuuint32_t = ::std::os::raw::c_uint;
pub type cuuint64_t = ::std::os::raw::c_ulonglong;
pub type CUdeviceptr = ::std::os::raw::c_ulonglong;
pub type CUdevice = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUctx_st {
    _unused: [u8; 0],
}
pub type CUcontext = *mut CUctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmod_st {
    _unused: [u8; 0],
}
pub type CUmodule = *mut CUmod_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUfunc_st {
    _unused: [u8; 0],
}
pub type CUfunction = *mut CUfunc_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUarray_st {
    _unused: [u8; 0],
}
pub type CUarray = *mut CUarray_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmipmappedArray_st {
    _unused: [u8; 0],
}
pub type CUmipmappedArray = *mut CUmipmappedArray_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUtexref_st {
    _unused: [u8; 0],
}
pub type CUtexref = *mut CUtexref_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUsurfref_st {
    _unused: [u8; 0],
}
pub type CUsurfref = *mut CUsurfref_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUevent_st {
    _unused: [u8; 0],
}
pub type CUevent = *mut CUevent_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUstream_st {
    _unused: [u8; 0],
}
pub type CUstream = *mut CUstream_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraphicsResource_st {
    _unused: [u8; 0],
}
pub type CUgraphicsResource = *mut CUgraphicsResource_st;
pub type CUtexObject = ::std::os::raw::c_ulonglong;
pub type CUsurfObject = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUextMemory_st {
    _unused: [u8; 0],
}
pub type CUexternalMemory = *mut CUextMemory_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUextSemaphore_st {
    _unused: [u8; 0],
}
pub type CUexternalSemaphore = *mut CUextSemaphore_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraph_st {
    _unused: [u8; 0],
}
pub type CUgraph = *mut CUgraph_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraphNode_st {
    _unused: [u8; 0],
}
pub type CUgraphNode = *mut CUgraphNode_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraphExec_st {
    _unused: [u8; 0],
}
pub type CUgraphExec = *mut CUgraphExec_st;
#[repr(C)]
pub struct CUuuid_st {
    pub bytes: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout_CUuuid_st() {
    assert_eq!(
        ::std::mem::size_of::<CUuuid_st>(),
        16usize,
        concat!("Size of: ", stringify!(CUuuid_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUuuid_st>(),
        1usize,
        concat!("Alignment of ", stringify!(CUuuid_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUuuid_st>())).bytes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUuuid_st),
            "::",
            stringify!(bytes)
        )
    );
}
pub type CUuuid = CUuuid_st;
/// CUDA IPC event handle
#[repr(C)]
pub struct CUipcEventHandle_st {
    pub reserved: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_CUipcEventHandle_st() {
    assert_eq!(
        ::std::mem::size_of::<CUipcEventHandle_st>(),
        64usize,
        concat!("Size of: ", stringify!(CUipcEventHandle_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUipcEventHandle_st>(),
        1usize,
        concat!("Alignment of ", stringify!(CUipcEventHandle_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUipcEventHandle_st>())).reserved as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUipcEventHandle_st),
            "::",
            stringify!(reserved)
        )
    );
}
pub type CUipcEventHandle = CUipcEventHandle_st;
/// CUDA IPC mem handle
#[repr(C)]
pub struct CUipcMemHandle_st {
    pub reserved: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_CUipcMemHandle_st() {
    assert_eq!(
        ::std::mem::size_of::<CUipcMemHandle_st>(),
        64usize,
        concat!("Size of: ", stringify!(CUipcMemHandle_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUipcMemHandle_st>(),
        1usize,
        concat!("Alignment of ", stringify!(CUipcMemHandle_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUipcMemHandle_st>())).reserved as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUipcMemHandle_st),
            "::",
            stringify!(reserved)
        )
    );
}
pub type CUipcMemHandle = CUipcMemHandle_st;
#[repr(i32)]
/// CUDA Ipc Mem Flags
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CUipcMem_flags_enum {
    ///< Automatically enable peer access between remote devices as needed
    CU_IPC_MEM_LAZY_ENABLE_PEER_ACCESS = 1,
}
pub use self::CUipcMem_flags_enum as CUipcMem_flags;
#[repr(i32)]
/// CUDA Mem Attach Flags
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CUmemAttach_flags_enum {
    ///< Memory can be accessed by any stream on any device
    CU_MEM_ATTACH_GLOBAL = 1,
    ///< Memory cannot be accessed by any stream on any device
    CU_MEM_ATTACH_HOST = 2,
    ///< Memory can only be accessed by a single stream on the associated device
    CU_MEM_ATTACH_SINGLE = 4,
}
pub use self::CUmemAttach_flags_enum as CUmemAttach_flags;
impl CUctx_flags_enum {
    pub const CU_CTX_BLOCKING_SYNC: CUctx_flags_enum = CUctx_flags_enum::CU_CTX_SCHED_BLOCKING_SYNC;
}
#[repr(i32)]
/// Context creation flags
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CUctx_flags_enum {
    ///< Automatic scheduling
    CU_CTX_SCHED_AUTO = 0,
    ///< Set spin as default scheduling
    CU_CTX_SCHED_SPIN = 1,
    ///< Set yield as default scheduling
    CU_CTX_SCHED_YIELD = 2,
    ///< Set blocking synchronization as default scheduling
    CU_CTX_SCHED_BLOCKING_SYNC = 4,
    CU_CTX_SCHED_MASK = 7,
    ///< Support mapped pinned allocations
    CU_CTX_MAP_HOST = 8,
    ///< Keep local memory allocation after launch
    CU_CTX_LMEM_RESIZE_TO_MAX = 16,
    CU_CTX_FLAGS_MASK = 31,
}
pub use self::CUctx_flags_enum as CUctx_flags;
#[repr(i32)]
/// Stream creation flags
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CUstream_flags_enum {
    ///< Default stream flag
    CU_STREAM_DEFAULT = 0,
    ///< Stream does not synchronize with stream 0 (the NULL stream)
    CU_STREAM_NON_BLOCKING = 1,
}
pub use self::CUstream_flags_enum as CUstream_flags;
#[repr(i32)]
/// Event creation flags
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CUevent_flags_enum {
    ///< Default event flag
    CU_EVENT_DEFAULT = 0,
    ///< Event uses blocking synchronization
    CU_EVENT_BLOCKING_SYNC = 1,
    ///< Event will not record timing data
    CU_EVENT_DISABLE_TIMING = 2,
    ///< Event is suitable for interprocess use. CU_EVENT_DISABLE_TIMING must be set
    CU_EVENT_INTERPROCESS = 4,
}
pub use self::CUevent_flags_enum as CUevent_flags;
#[repr(i32)]
/// Flags for ::cuStreamWaitValue32 and ::cuStreamWaitValue64
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CUstreamWaitValue_flags_enum {
    ///< Wait until (int32_t)(*addr - value) >= 0 (or int64_t for 64 bit
    ///values). Note this is a cyclic comparison which ignores wraparound.
    ///(Default behavior.)
    CU_STREAM_WAIT_VALUE_GEQ = 0,
    ///< Wait until *addr == value.
    CU_STREAM_WAIT_VALUE_EQ = 1,
    ///< Wait until (*addr & value) != 0.
    CU_STREAM_WAIT_VALUE_AND = 2,
    ///< Wait until ~(*addr | value) != 0. Support for this operation can be
    ///queried with ::cuDeviceGetAttribute() and
    ///::CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR.
    CU_STREAM_WAIT_VALUE_NOR = 3,
    ///< Follow the wait operation with a flush of outstanding remote writes. This
    ///means that, if a remote write operation is guaranteed to have reached the
    ///device before the wait can be satisfied, that write is guaranteed to be
    ///visible to downstream device work. The device is permitted to reorder
    ///remote writes internally. For example, this flag would be required if
    ///two remote writes arrive in a defined order, the wait is satisfied by the
    ///second write, and downstream work needs to observe the first write.
    ///Support for this operation is restricted to selected platforms and can be
    ///queried with ::CU_DEVICE_ATTRIBUTE_CAN_USE_WAIT_VALUE_FLUSH.
    CU_STREAM_WAIT_VALUE_FLUSH = 1073741824,
}
pub use self::CUstreamWaitValue_flags_enum as CUstreamWaitValue_flags;
#[repr(i32)]
/// Flags for ::cuStreamWriteValue32
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CUstreamWriteValue_flags_enum {
    ///< Default behavior
    CU_STREAM_WRITE_VALUE_DEFAULT = 0,
    ///< Permits the write to be reordered with writes which were issued
    ///before it, as a performance optimization. Normally,
    ///::cuStreamWriteValue32 will provide a memory fence before the
    ///write, which has similar semantics to
    ///__threadfence_system() but is scoped to the stream
    ///rather than a CUDA thread.
    CU_STREAM_WRITE_VALUE_NO_MEMORY_BARRIER = 1,
}
pub use self::CUstreamWriteValue_flags_enum as CUstreamWriteValue_flags;
#[repr(i32)]
/// Operations for ::cuStreamBatchMemOp
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CUstreamBatchMemOpType_enum {
    ///< Represents a ::cuStreamWaitValue32 operation
    CU_STREAM_MEM_OP_WAIT_VALUE_32 = 1,
    ///< Represents a ::cuStreamWriteValue32 operation
    CU_STREAM_MEM_OP_WRITE_VALUE_32 = 2,
    ///< Represents a ::cuStreamWaitValue64 operation
    CU_STREAM_MEM_OP_WAIT_VALUE_64 = 4,
    ///< Represents a ::cuStreamWriteValue64 operation
    CU_STREAM_MEM_OP_WRITE_VALUE_64 = 5,
    ///< This has the same effect as ::CU_STREAM_WAIT_VALUE_FLUSH, but as a
    ///standalone operation.
    CU_STREAM_MEM_OP_FLUSH_REMOTE_WRITES = 3,
}
pub use self::CUstreamBatchMemOpType_enum as CUstreamBatchMemOpType;
/// Per-operation parameters for ::cuStreamBatchMemOp
#[repr(C)]
pub struct CUstreamBatchMemOpParams_union {
    pub operation: __BindgenUnionField<CUstreamBatchMemOpType>,
    pub waitValue:
        __BindgenUnionField<CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st>,
    pub writeValue:
        __BindgenUnionField<CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st>,
    pub flushRemoteWrites:
        __BindgenUnionField<CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st>,
    pub pad: __BindgenUnionField<[cuuint64_t; 6usize]>,
    pub bindgen_union_field: [u64; 6usize],
}
#[repr(C)]
pub struct CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st {
    pub operation: CUstreamBatchMemOpType,
    pub address: CUdeviceptr,
    pub __bindgen_anon_1:
        CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1,
    pub flags: ::std::os::raw::c_uint,
    ///< For driver internal use. Initial value is unimportant.
    pub alias: CUdeviceptr,
}
#[repr(C)]
pub struct CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1 {
    pub value: __BindgenUnionField<cuuint32_t>,
    pub value64: __BindgenUnionField<cuuint64_t>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1(
) {
    assert_eq!(
        ::std::mem::size_of::<
            CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1,
        >(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(
                CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1,
        >(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(
                CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1,
            >()))
            .value as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1
            ),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1,
            >()))
            .value64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1
            ),
            "::",
            stringify!(value64)
        )
    );
}
#[test]
fn bindgen_test_layout_CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st() {
    assert_eq!(
        ::std::mem::size_of::<CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st>(
            )))
            .operation as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st),
            "::",
            stringify!(operation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st>(
            )))
            .address as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st>(
            )))
            .flags as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st>(
            )))
            .alias as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st),
            "::",
            stringify!(alias)
        )
    );
}
#[repr(C)]
pub struct CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st {
    pub operation: CUstreamBatchMemOpType,
    pub address: CUdeviceptr,
    pub __bindgen_anon_1:
        CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1,
    pub flags: ::std::os::raw::c_uint,
    ///< For driver internal use. Initial value is unimportant.
    pub alias: CUdeviceptr,
}
#[repr(C)]
pub struct CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1 {
    pub value: __BindgenUnionField<cuuint32_t>,
    pub value64: __BindgenUnionField<cuuint64_t>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1(
) {
    assert_eq!(
        ::std::mem::size_of::<
            CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1,
        >(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(
                CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1,
        >(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(
                CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1,
            >()))
            .value as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1
            ),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1,
            >()))
            .value64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1
            ),
            "::",
            stringify!(value64)
        )
    );
}
#[test]
fn bindgen_test_layout_CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st() {
    assert_eq!(
        ::std::mem::size_of::<CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st>(
            )))
            .operation as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st),
            "::",
            stringify!(operation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st>(
            )))
            .address as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st>(
            )))
            .flags as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st>(
            )))
            .alias as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st),
            "::",
            stringify!(alias)
        )
    );
}
#[repr(C)]
pub struct CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st {
    pub operation: CUstreamBatchMemOpType,
    pub flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st() {
    assert_eq!(
        ::std::mem::size_of::<CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st>(
        ),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st,
            >()))
            .operation as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st),
            "::",
            stringify!(operation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st,
            >()))
            .flags as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st),
            "::",
            stringify!(flags)
        )
    );
}
#[test]
fn bindgen_test_layout_CUstreamBatchMemOpParams_union() {
    assert_eq!(
        ::std::mem::size_of::<CUstreamBatchMemOpParams_union>(),
        48usize,
        concat!("Size of: ", stringify!(CUstreamBatchMemOpParams_union))
    );
    assert_eq!(
        ::std::mem::align_of::<CUstreamBatchMemOpParams_union>(),
        8usize,
        concat!("Alignment of ", stringify!(CUstreamBatchMemOpParams_union))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUstreamBatchMemOpParams_union>())).operation as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union),
            "::",
            stringify!(operation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUstreamBatchMemOpParams_union>())).waitValue as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union),
            "::",
            stringify!(waitValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUstreamBatchMemOpParams_union>())).writeValue as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union),
            "::",
            stringify!(writeValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUstreamBatchMemOpParams_union>())).flushRemoteWrites as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union),
            "::",
            stringify!(flushRemoteWrites)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUstreamBatchMemOpParams_union>())).pad as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union),
            "::",
            stringify!(pad)
        )
    );
}
pub type CUstreamBatchMemOpParams = CUstreamBatchMemOpParams_union;
#[repr(i32)]
/// Occupancy calculator flag
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CUoccupancy_flags_enum {
    ///< Default behavior
    CU_OCCUPANCY_DEFAULT = 0,
    ///< Assume global caching is enabled and cannot be automatically turned off
    CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE = 1,
}
pub use self::CUoccupancy_flags_enum as CUoccupancy_flags;
#[repr(i32)]
/// Array formats
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CUarray_format_enum {
    ///< Unsigned 8-bit integers
    CU_AD_FORMAT_UNSIGNED_INT8 = 1,
    ///< Unsigned 16-bit integers
    CU_AD_FORMAT_UNSIGNED_INT16 = 2,
    ///< Unsigned 32-bit integers
    CU_AD_FORMAT_UNSIGNED_INT32 = 3,
    ///< Signed 8-bit integers
    CU_AD_FORMAT_SIGNED_INT8 = 8,
    ///< Signed 16-bit integers
    CU_AD_FORMAT_SIGNED_INT16 = 9,
    ///< Signed 32-bit integers
    CU_AD_FORMAT_SIGNED_INT32 = 10,
    ///< 16-bit floating point
    CU_AD_FORMAT_HALF = 16,
    ///< 32-bit floating point
    CU_AD_FORMAT_FLOAT = 32,
}
pub use self::CUarray_format_enum as CUarray_format;
#[repr(i32)]
/// Texture reference addressing modes
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CUaddress_mode_enum {
    ///< Wrapping address mode
    CU_TR_ADDRESS_MODE_WRAP = 0,
    ///< Clamp to edge address mode
    CU_TR_ADDRESS_MODE_CLAMP = 1,
    ///< Mirror address mode
    CU_TR_ADDRESS_MODE_MIRROR = 2,
    ///< Border address mode
    CU_TR_ADDRESS_MODE_BORDER = 3,
}
pub use self::CUaddress_mode_enum as CUaddress_mode;
#[repr(i32)]
/// Texture reference filtering modes
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CUfilter_mode_enum {
    ///< Point filter mode
    CU_TR_FILTER_MODE_POINT = 0,
    ///< Linear filter mode
    CU_TR_FILTER_MODE_LINEAR = 1,
}
pub use self::CUfilter_mode_enum as CUfilter_mode;
impl CUdevice_attribute_enum {
    pub const CU_DEVICE_ATTRIBUTE_SHARED_MEMORY_PER_BLOCK: CUdevice_attribute_enum =
        CUdevice_attribute_enum::CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK;
}
impl CUdevice_attribute_enum {
    pub const CU_DEVICE_ATTRIBUTE_REGISTERS_PER_BLOCK: CUdevice_attribute_enum =
        CUdevice_attribute_enum::CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK;
}
impl CUdevice_attribute_enum {
    pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_WIDTH: CUdevice_attribute_enum =
        CUdevice_attribute_enum::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH;
}
impl CUdevice_attribute_enum {
    pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_HEIGHT: CUdevice_attribute_enum =
        CUdevice_attribute_enum::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT;
}
impl CUdevice_attribute_enum {
    pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_NUMSLICES: CUdevice_attribute_enum =
        CUdevice_attribute_enum::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS;
}
#[repr(i32)]
/// Device properties
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CUdevice_attribute_enum {
    ///< Maximum number of threads per block
    CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK = 1,
    ///< Maximum block dimension X
    CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_X = 2,
    ///< Maximum block dimension Y
    CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Y = 3,
    ///< Maximum block dimension Z
    CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Z = 4,
    ///< Maximum grid dimension X
    CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_X = 5,
    ///< Maximum grid dimension Y
    CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Y = 6,
    ///< Maximum grid dimension Z
    CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Z = 7,
    ///< Maximum shared memory available per block in bytes
    CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK = 8,
    ///< Memory available on device for __constant__ variables in a CUDA C kernel in bytes
    CU_DEVICE_ATTRIBUTE_TOTAL_CONSTANT_MEMORY = 9,
    ///< Warp size in threads
    CU_DEVICE_ATTRIBUTE_WARP_SIZE = 10,
    ///< Maximum pitch in bytes allowed by memory copies
    CU_DEVICE_ATTRIBUTE_MAX_PITCH = 11,
    ///< Maximum number of 32-bit registers available per block
    CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK = 12,
    ///< Typical clock frequency in kilohertz
    CU_DEVICE_ATTRIBUTE_CLOCK_RATE = 13,
    ///< Alignment requirement for textures
    CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT = 14,
    ///< Device can possibly copy memory and execute a kernel concurrently. Deprecated. Use instead CU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT.
    CU_DEVICE_ATTRIBUTE_GPU_OVERLAP = 15,
    ///< Number of multiprocessors on device
    CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT = 16,
    ///< Specifies whether there is a run time limit on kernels
    CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT = 17,
    ///< Device is integrated with host memory
    CU_DEVICE_ATTRIBUTE_INTEGRATED = 18,
    ///< Device can map host memory into CUDA address space
    CU_DEVICE_ATTRIBUTE_CAN_MAP_HOST_MEMORY = 19,
    ///< Compute mode (See ::CUcomputemode for details)
    CU_DEVICE_ATTRIBUTE_COMPUTE_MODE = 20,
    ///< Maximum 1D texture width
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_WIDTH = 21,
    ///< Maximum 2D texture width
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_WIDTH = 22,
    ///< Maximum 2D texture height
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_HEIGHT = 23,
    ///< Maximum 3D texture width
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH = 24,
    ///< Maximum 3D texture height
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT = 25,
    ///< Maximum 3D texture depth
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH = 26,
    ///< Maximum 2D layered texture width
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH = 27,
    ///< Maximum 2D layered texture height
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT = 28,
    ///< Maximum layers in a 2D layered texture
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS = 29,
    ///< Alignment requirement for surfaces
    CU_DEVICE_ATTRIBUTE_SURFACE_ALIGNMENT = 30,
    ///< Device can possibly execute multiple kernels concurrently
    CU_DEVICE_ATTRIBUTE_CONCURRENT_KERNELS = 31,
    ///< Device has ECC support enabled
    CU_DEVICE_ATTRIBUTE_ECC_ENABLED = 32,
    ///< PCI bus ID of the device
    CU_DEVICE_ATTRIBUTE_PCI_BUS_ID = 33,
    ///< PCI device ID of the device
    CU_DEVICE_ATTRIBUTE_PCI_DEVICE_ID = 34,
    ///< Device is using TCC driver model
    CU_DEVICE_ATTRIBUTE_TCC_DRIVER = 35,
    ///< Peak memory clock frequency in kilohertz
    CU_DEVICE_ATTRIBUTE_MEMORY_CLOCK_RATE = 36,
    ///< Global memory bus width in bits
    CU_DEVICE_ATTRIBUTE_GLOBAL_MEMORY_BUS_WIDTH = 37,
    ///< Size of L2 cache in bytes
    CU_DEVICE_ATTRIBUTE_L2_CACHE_SIZE = 38,
    ///< Maximum resident threads per multiprocessor
    CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_MULTIPROCESSOR = 39,
    ///< Number of asynchronous engines
    CU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT = 40,
    ///< Device shares a unified address space with the host
    CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING = 41,
    ///< Maximum 1D layered texture width
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_WIDTH = 42,
    ///< Maximum layers in a 1D layered texture
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_LAYERS = 43,
    ///< Deprecated, do not use.
    CU_DEVICE_ATTRIBUTE_CAN_TEX2D_GATHER = 44,
    ///< Maximum 2D texture width if CUDA_ARRAY3D_TEXTURE_GATHER is set
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_WIDTH = 45,
    ///< Maximum 2D texture height if CUDA_ARRAY3D_TEXTURE_GATHER is set
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_HEIGHT = 46,
    ///< Alternate maximum 3D texture width
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH_ALTERNATE = 47,
    ///< Alternate maximum 3D texture height
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT_ALTERNATE = 48,
    ///< Alternate maximum 3D texture depth
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH_ALTERNATE = 49,
    ///< PCI domain ID of the device
    CU_DEVICE_ATTRIBUTE_PCI_DOMAIN_ID = 50,
    ///< Pitch alignment requirement for textures
    CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT = 51,
    ///< Maximum cubemap texture width/height
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_WIDTH = 52,
    ///< Maximum cubemap layered texture width/height
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_WIDTH = 53,
    ///< Maximum layers in a cubemap layered texture
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_LAYERS = 54,
    ///< Maximum 1D surface width
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_WIDTH = 55,
    ///< Maximum 2D surface width
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_WIDTH = 56,
    ///< Maximum 2D surface height
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_HEIGHT = 57,
    ///< Maximum 3D surface width
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_WIDTH = 58,
    ///< Maximum 3D surface height
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_HEIGHT = 59,
    ///< Maximum 3D surface depth
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_DEPTH = 60,
    ///< Maximum 1D layered surface width
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_WIDTH = 61,
    ///< Maximum layers in a 1D layered surface
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_LAYERS = 62,
    ///< Maximum 2D layered surface width
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_WIDTH = 63,
    ///< Maximum 2D layered surface height
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_HEIGHT = 64,
    ///< Maximum layers in a 2D layered surface
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_LAYERS = 65,
    ///< Maximum cubemap surface width
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_WIDTH = 66,
    ///< Maximum cubemap layered surface width
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_WIDTH = 67,
    ///< Maximum layers in a cubemap layered surface
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_LAYERS = 68,
    ///< Maximum 1D linear texture width
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH = 69,
    ///< Maximum 2D linear texture width
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH = 70,
    ///< Maximum 2D linear texture height
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT = 71,
    ///< Maximum 2D linear texture pitch in bytes
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH = 72,
    ///< Maximum mipmapped 2D texture width
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_WIDTH = 73,
    ///< Maximum mipmapped 2D texture height
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_HEIGHT = 74,
    ///< Major compute capability version number
    CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR = 75,
    ///< Minor compute capability version number
    CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR = 76,
    ///< Maximum mipmapped 1D texture width
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_MIPMAPPED_WIDTH = 77,
    ///< Device supports stream priorities
    CU_DEVICE_ATTRIBUTE_STREAM_PRIORITIES_SUPPORTED = 78,
    ///< Device supports caching globals in L1
    CU_DEVICE_ATTRIBUTE_GLOBAL_L1_CACHE_SUPPORTED = 79,
    ///< Device supports caching locals in L1
    CU_DEVICE_ATTRIBUTE_LOCAL_L1_CACHE_SUPPORTED = 80,
    ///< Maximum shared memory available per multiprocessor in bytes
    CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR = 81,
    ///< Maximum number of 32-bit registers available per multiprocessor
    CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_MULTIPROCESSOR = 82,
    ///< Device can allocate managed memory on this system
    CU_DEVICE_ATTRIBUTE_MANAGED_MEMORY = 83,
    ///< Device is on a multi-GPU board
    CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD = 84,
    ///< Unique id for a group of devices on the same multi-GPU board
    CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD_GROUP_ID = 85,
    ///< Link between the device and the host supports native atomic operations (this is a placeholder attribute, and is not supported on any current hardware)
    CU_DEVICE_ATTRIBUTE_HOST_NATIVE_ATOMIC_SUPPORTED = 86,
    ///< Ratio of single precision performance (in floating-point operations per second) to double precision performance
    CU_DEVICE_ATTRIBUTE_SINGLE_TO_DOUBLE_PRECISION_PERF_RATIO = 87,
    ///< Device supports coherently accessing pageable memory without calling cudaHostRegister on it
    CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS = 88,
    ///< Device can coherently access managed memory concurrently with the CPU
    CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS = 89,
    ///< Device supports compute preemption.
    CU_DEVICE_ATTRIBUTE_COMPUTE_PREEMPTION_SUPPORTED = 90,
    ///< Device can access host registered memory at the same virtual address as the CPU
    CU_DEVICE_ATTRIBUTE_CAN_USE_HOST_POINTER_FOR_REGISTERED_MEM = 91,
    ///< ::cuStreamBatchMemOp and related APIs are supported.
    CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_MEM_OPS = 92,
    ///< 64-bit operations are supported in ::cuStreamBatchMemOp and related APIs.
    CU_DEVICE_ATTRIBUTE_CAN_USE_64_BIT_STREAM_MEM_OPS = 93,
    ///< ::CU_STREAM_WAIT_VALUE_NOR is supported.
    CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR = 94,
    ///< Device supports launching cooperative kernels via ::cuLaunchCooperativeKernel
    CU_DEVICE_ATTRIBUTE_COOPERATIVE_LAUNCH = 95,
    ///< Device can participate in cooperative kernels launched via ::cuLaunchCooperativeKernelMultiDevice
    CU_DEVICE_ATTRIBUTE_COOPERATIVE_MULTI_DEVICE_LAUNCH = 96,
    ///< Maximum optin shared memory per block
    CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK_OPTIN = 97,
    ///< Both the ::CU_STREAM_WAIT_VALUE_FLUSH flag and the ::CU_STREAM_MEM_OP_FLUSH_REMOTE_WRITES MemOp are supported on the device. See \ref CUDA_MEMOP for additional details.
    CU_DEVICE_ATTRIBUTE_CAN_FLUSH_REMOTE_WRITES = 98,
    ///< Device supports host memory registration via ::cudaHostRegister.
    CU_DEVICE_ATTRIBUTE_HOST_REGISTER_SUPPORTED = 99,
    ///< Device accesses pageable memory via the host's page tables.
    CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES = 100,
    ///< The host can directly access managed memory on the device without migration.
    CU_DEVICE_ATTRIBUTE_DIRECT_MANAGED_MEM_ACCESS_FROM_HOST = 101,
    CU_DEVICE_ATTRIBUTE_MAX = 102,
}
pub use self::CUdevice_attribute_enum as CUdevice_attribute;
/// Legacy device properties
#[repr(C)]
pub struct CUdevprop_st {
    ///< Maximum number of threads per block
    pub maxThreadsPerBlock: ::std::os::raw::c_int,
    ///< Maximum size of each dimension of a block
    pub maxThreadsDim: [::std::os::raw::c_int; 3usize],
    ///< Maximum size of each dimension of a grid
    pub maxGridSize: [::std::os::raw::c_int; 3usize],
    ///< Shared memory available per block in bytes
    pub sharedMemPerBlock: ::std::os::raw::c_int,
    ///< Constant memory available on device in bytes
    pub totalConstantMemory: ::std::os::raw::c_int,
    ///< Warp size in threads
    pub SIMDWidth: ::std::os::raw::c_int,
    ///< Maximum pitch in bytes allowed by memory copies
    pub memPitch: ::std::os::raw::c_int,
    ///< 32-bit registers available per block
    pub regsPerBlock: ::std::os::raw::c_int,
    ///< Clock frequency in kilohertz
    pub clockRate: ::std::os::raw::c_int,
    ///< Alignment requirement for textures
    pub textureAlign: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CUdevprop_st() {
    assert_eq!(
        ::std::mem::size_of::<CUdevprop_st>(),
        56usize,
        concat!("Size of: ", stringify!(CUdevprop_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUdevprop_st>(),
        4usize,
        concat!("Alignment of ", stringify!(CUdevprop_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUdevprop_st>())).maxThreadsPerBlock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUdevprop_st),
            "::",
            stringify!(maxThreadsPerBlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUdevprop_st>())).maxThreadsDim as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUdevprop_st),
            "::",
            stringify!(maxThreadsDim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUdevprop_st>())).maxGridSize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUdevprop_st),
            "::",
            stringify!(maxGridSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUdevprop_st>())).sharedMemPerBlock as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CUdevprop_st),
            "::",
            stringify!(sharedMemPerBlock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUdevprop_st>())).totalConstantMemory as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUdevprop_st),
            "::",
            stringify!(totalConstantMemory)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUdevprop_st>())).SIMDWidth as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(CUdevprop_st),
            "::",
            stringify!(SIMDWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUdevprop_st>())).memPitch as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CUdevprop_st),
            "::",
            stringify!(memPitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUdevprop_st>())).regsPerBlock as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(CUdevprop_st),
            "::",
            stringify!(regsPerBlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUdevprop_st>())).clockRate as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CUdevprop_st),
            "::",
            stringify!(clockRate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUdevprop_st>())).textureAlign as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(CUdevprop_st),
            "::",
            stringify!(textureAlign)
        )
    );
}
pub type CUdevprop = CUdevprop_st;
#[repr(i32)]
/// Pointer information
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CUpointer_attribute_enum {
    ///< The ::CUcontext on which a pointer was allocated or registered
    CU_POINTER_ATTRIBUTE_CONTEXT = 1,
    ///< The ::CUmemorytype describing the physical location of a pointer
    CU_POINTER_ATTRIBUTE_MEMORY_TYPE = 2,
    ///< The address at which a pointer's memory may be accessed on the device
    CU_POINTER_ATTRIBUTE_DEVICE_POINTER = 3,
    ///< The address at which a pointer's memory may be accessed on the host
    CU_POINTER_ATTRIBUTE_HOST_POINTER = 4,
    ///< A pair of tokens for use with the nv-p2p.h Linux kernel interface
    CU_POINTER_ATTRIBUTE_P2P_TOKENS = 5,
    ///< Synchronize every synchronous memory operation initiated on this region
    CU_POINTER_ATTRIBUTE_SYNC_MEMOPS = 6,
    ///< A process-wide unique ID for an allocated memory region
    CU_POINTER_ATTRIBUTE_BUFFER_ID = 7,
    ///< Indicates if the pointer points to managed memory
    CU_POINTER_ATTRIBUTE_IS_MANAGED = 8,
    ///< A device ordinal of a device on which a pointer was allocated or registered
    CU_POINTER_ATTRIBUTE_DEVICE_ORDINAL = 9,
}
pub use self::CUpointer_attribute_enum as CUpointer_attribute;
#[repr(i32)]
/// Function properties
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CUfunction_attribute_enum {
    /// The maximum number of threads per block, beyond which a launch of the
    /// function would fail. This number depends on both the function and the
    /// device on which the function is currently loaded.
    CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK = 0,
    /// The size in bytes of statically-allocated shared memory required by
    /// this function. This does not include dynamically-allocated shared
    /// memory requested by the user at runtime.
    CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES = 1,
    /// The size in bytes of user-allocated constant memory required by this
    /// function.
    CU_FUNC_ATTRIBUTE_CONST_SIZE_BYTES = 2,
    /// The size in bytes of local memory used by each thread of this function.
    CU_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES = 3,
    /// The number of registers used by each thread of this function.
    CU_FUNC_ATTRIBUTE_NUM_REGS = 4,
    /// The PTX virtual architecture version for which the function was
    /// compiled. This value is the major PTX version * 10 + the minor PTX
    /// version, so a PTX version 1.3 function would return the value 13.
    /// Note that this may return the undefined value of 0 for cubins
    /// compiled prior to CUDA 3.0.
    CU_FUNC_ATTRIBUTE_PTX_VERSION = 5,
    /// The binary architecture version for which the function was compiled.
    /// This value is the major binary version * 10 + the minor binary version,
    /// so a binary version 1.3 function would return the value 13. Note that
    /// this will return a value of 10 for legacy cubins that do not have a
    /// properly-encoded binary architecture version.
    CU_FUNC_ATTRIBUTE_BINARY_VERSION = 6,
    /// The attribute to indicate whether the function has been compiled with
    /// user specified option "-Xptxas --dlcm=ca" set .
    CU_FUNC_ATTRIBUTE_CACHE_MODE_CA = 7,
    /// The maximum size in bytes of dynamically-allocated shared memory that can be used by
    /// this function. If the user-specified dynamic shared memory size is larger than this
    /// value, the launch will fail.
    CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES = 8,
    /// On devices where the L1 cache and shared memory use the same hardware resources,
    /// this sets the shared memory carveout preference, in percent of the total resources.
    /// This is only a hint, and the driver can choose a different ratio if required to execute the function.
    CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT = 9,
    /// On devices where the L1 cache and shared memory use the same hardware resources,
    /// this sets the shared memory carveout preference, in percent of the total resources.
    /// This is only a hint, and the driver can choose a different ratio if required to execute the function.
    CU_FUNC_ATTRIBUTE_MAX = 10,
}
pub use self::CUfunction_attribute_enum as CUfunction_attribute;
#[repr(i32)]
/// Function cache configurations
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CUfunc_cache_enum {
    ///< no preference for shared memory or L1 (default)
    CU_FUNC_CACHE_PREFER_NONE = 0,
    ///< prefer larger shared memory and smaller L1 cache
    CU_FUNC_CACHE_PREFER_SHARED = 1,
    ///< prefer larger L1 cache and smaller shared memory
    CU_FUNC_CACHE_PREFER_L1 = 2,
    ///< prefer equal sized L1 cache and shared memory
    CU_FUNC_CACHE_PREFER_EQUAL = 3,
}
pub use self::CUfunc_cache_enum as CUfunc_cache;
#[repr(i32)]
/// Shared memory configurations
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CUsharedconfig_enum {
    ///< set default shared memory bank size
    CU_SHARED_MEM_CONFIG_DEFAULT_BANK_SIZE = 0,
    ///< set shared memory bank width to four bytes
    CU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE = 1,
    ///< set shared memory bank width to eight bytes
    CU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE = 2,
}
pub use self::CUsharedconfig_enum as CUsharedconfig;
#[repr(i32)]
/// Shared memory carveout configurations
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CUshared_carveout_enum {
    CU_SHAREDMEM_CARVEOUT_DEFAULT = -1,
    /// < no preference for shared memory or L1 (default)
    CU_SHAREDMEM_CARVEOUT_MAX_SHARED = 100,
    /// < prefer maximum available shared memory, minimum L1 cache
    CU_SHAREDMEM_CARVEOUT_MAX_L1 = 0,
}
pub use self::CUshared_carveout_enum as CUshared_carveout;
#[repr(i32)]
/// Memory types
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CUmemorytype_enum {
    ///< Host memory
    CU_MEMORYTYPE_HOST = 1,
    ///< Device memory
    CU_MEMORYTYPE_DEVICE = 2,
    ///< Array memory
    CU_MEMORYTYPE_ARRAY = 3,
    ///< Unified device or host memory
    CU_MEMORYTYPE_UNIFIED = 4,
}
pub use self::CUmemorytype_enum as CUmemorytype;
#[repr(i32)]
/// Compute Modes
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CUcomputemode_enum {
    ///< Default compute mode (Multiple contexts allowed per device)
    CU_COMPUTEMODE_DEFAULT = 0,
    ///< Compute-prohibited mode (No contexts can be created on this device at this time)
    CU_COMPUTEMODE_PROHIBITED = 2,
    ///< Compute-exclusive-process mode (Only one context used by a single process can be present on this device at a time)
    CU_COMPUTEMODE_EXCLUSIVE_PROCESS = 3,
}
pub use self::CUcomputemode_enum as CUcomputemode;
#[repr(i32)]
/// Memory advise values
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CUmem_advise_enum {
    ///< Data will mostly be read and only occassionally be written to
    CU_MEM_ADVISE_SET_READ_MOSTLY = 1,
    ///< Undo the effect of ::CU_MEM_ADVISE_SET_READ_MOSTLY
    CU_MEM_ADVISE_UNSET_READ_MOSTLY = 2,
    ///< Set the preferred location for the data as the specified device
    CU_MEM_ADVISE_SET_PREFERRED_LOCATION = 3,
    ///< Clear the preferred location for the data
    CU_MEM_ADVISE_UNSET_PREFERRED_LOCATION = 4,
    ///< Data will be accessed by the specified device, so prevent page faults as much as possible
    CU_MEM_ADVISE_SET_ACCESSED_BY = 5,
    ///< Let the Unified Memory subsystem decide on the page faulting policy for the specified device
    CU_MEM_ADVISE_UNSET_ACCESSED_BY = 6,
}
pub use self::CUmem_advise_enum as CUmem_advise;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CUmem_range_attribute_enum {
    ///< Whether the range will mostly be read and only occassionally be written to
    CU_MEM_RANGE_ATTRIBUTE_READ_MOSTLY = 1,
    ///< The preferred location of the range
    CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION = 2,
    ///< Memory range has ::CU_MEM_ADVISE_SET_ACCESSED_BY set for specified device
    CU_MEM_RANGE_ATTRIBUTE_ACCESSED_BY = 3,
    ///< The last location to which the range was prefetched
    CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION = 4,
}
pub use self::CUmem_range_attribute_enum as CUmem_range_attribute;
#[repr(i32)]
/// Online compiler and linker options
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CUjit_option_enum {
    /// Max number of registers that a thread may use.\n
    /// Option type: unsigned int\n
    /// Applies to: compiler only
    CU_JIT_MAX_REGISTERS = 0,
    /// IN: Specifies minimum number of threads per block to target compilation
    /// for\n
    /// OUT: Returns the number of threads the compiler actually targeted.
    /// This restricts the resource utilization fo the compiler (e.g. max
    /// registers) such that a block with the given number of threads should be
    /// able to launch based on register limitations. Note, this option does not
    /// currently take into account any other resource limitations, such as
    /// shared memory utilization.\n
    /// Cannot be combined with ::CU_JIT_TARGET.\n
    /// Option type: unsigned int\n
    /// Applies to: compiler only
    CU_JIT_THREADS_PER_BLOCK = 1,
    /// Overwrites the option value with the total wall clock time, in
    /// milliseconds, spent in the compiler and linker\n
    /// Option type: float\n
    /// Applies to: compiler and linker
    CU_JIT_WALL_TIME = 2,
    /// Pointer to a buffer in which to print any log messages
    /// that are informational in nature (the buffer size is specified via
    /// option ::CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES)\n
    /// Option type: char *\n
    /// Applies to: compiler and linker
    CU_JIT_INFO_LOG_BUFFER = 3,
    /// IN: Log buffer size in bytes.  Log messages will be capped at this size
    /// (including null terminator)\n
    /// OUT: Amount of log buffer filled with messages\n
    /// Option type: unsigned int\n
    /// Applies to: compiler and linker
    CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES = 4,
    /// Pointer to a buffer in which to print any log messages that
    /// reflect errors (the buffer size is specified via option
    /// ::CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES)\n
    /// Option type: char *\n
    /// Applies to: compiler and linker
    CU_JIT_ERROR_LOG_BUFFER = 5,
    /// IN: Log buffer size in bytes.  Log messages will be capped at this size
    /// (including null terminator)\n
    /// OUT: Amount of log buffer filled with messages\n
    /// Option type: unsigned int\n
    /// Applies to: compiler and linker
    CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES = 6,
    /// Level of optimizations to apply to generated code (0 - 4), with 4
    /// being the default and highest level of optimizations.\n
    /// Option type: unsigned int\n
    /// Applies to: compiler only
    CU_JIT_OPTIMIZATION_LEVEL = 7,
    /// No option value required. Determines the target based on the current
    /// attached context (default)\n
    /// Option type: No option value needed\n
    /// Applies to: compiler and linker
    CU_JIT_TARGET_FROM_CUCONTEXT = 8,
    /// Target is chosen based on supplied ::CUjit_target.  Cannot be
    /// combined with ::CU_JIT_THREADS_PER_BLOCK.\n
    /// Option type: unsigned int for enumerated type ::CUjit_target\n
    /// Applies to: compiler and linker
    CU_JIT_TARGET = 9,
    /// Specifies choice of fallback strategy if matching cubin is not found.
    /// Choice is based on supplied ::CUjit_fallback.  This option cannot be
    /// used with cuLink* APIs as the linker requires exact matches.\n
    /// Option type: unsigned int for enumerated type ::CUjit_fallback\n
    /// Applies to: compiler only
    CU_JIT_FALLBACK_STRATEGY = 10,
    /// Specifies whether to create debug information in output (-g)
    /// (0: false, default)\n
    /// Option type: int\n
    /// Applies to: compiler and linker
    CU_JIT_GENERATE_DEBUG_INFO = 11,
    /// Generate verbose log messages (0: false, default)\n
    /// Option type: int\n
    /// Applies to: compiler and linker
    CU_JIT_LOG_VERBOSE = 12,
    /// Generate line number information (-lineinfo) (0: false, default)\n
    /// Option type: int\n
    /// Applies to: compiler only
    CU_JIT_GENERATE_LINE_INFO = 13,
    /// Specifies whether to enable caching explicitly (-dlcm) \n
    /// Choice is based on supplied ::CUjit_cacheMode_enum.\n
    /// Option type: unsigned int for enumerated type ::CUjit_cacheMode_enum\n
    /// Applies to: compiler only
    CU_JIT_CACHE_MODE = 14,
    /// The below jit options are used for internal purposes only, in this version of CUDA
    CU_JIT_NEW_SM3X_OPT = 15,
    /// The below jit options are used for internal purposes only, in this version of CUDA
    CU_JIT_FAST_COMPILE = 16,
    /// Array of device symbol names that will be relocated to the corresponing
    /// host addresses stored in ::CU_JIT_GLOBAL_SYMBOL_ADDRESSES.\n
    /// Must contain ::CU_JIT_GLOBAL_SYMBOL_COUNT entries.\n
    /// When loding a device module, driver will relocate all encountered
    /// unresolved symbols to the host addresses.\n
    /// It is only allowed to register symbols that correspond to unresolved
    /// global variables.\n
    /// It is illegal to register the same device symbol at multiple addresses.\n
    /// Option type: const char **\n
    /// Applies to: dynamic linker only
    CU_JIT_GLOBAL_SYMBOL_NAMES = 17,
    /// Array of host addresses that will be used to relocate corresponding
    /// device symbols stored in ::CU_JIT_GLOBAL_SYMBOL_NAMES.\n
    /// Must contain ::CU_JIT_GLOBAL_SYMBOL_COUNT entries.\n
    /// Option type: void **\n
    /// Applies to: dynamic linker only
    CU_JIT_GLOBAL_SYMBOL_ADDRESSES = 18,
    /// Number of entries in ::CU_JIT_GLOBAL_SYMBOL_NAMES and
    /// ::CU_JIT_GLOBAL_SYMBOL_ADDRESSES arrays.\n
    /// Option type: unsigned int\n
    /// Applies to: dynamic linker only
    CU_JIT_GLOBAL_SYMBOL_COUNT = 19,
    /// Number of entries in ::CU_JIT_GLOBAL_SYMBOL_NAMES and
    /// ::CU_JIT_GLOBAL_SYMBOL_ADDRESSES arrays.\n
    /// Option type: unsigned int\n
    /// Applies to: dynamic linker only
    CU_JIT_NUM_OPTIONS = 20,
}
pub use self::CUjit_option_enum as CUjit_option;
#[repr(i32)]
/// Online compilation targets
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CUjit_target_enum {
    ///< Compute device class 2.0
    CU_TARGET_COMPUTE_20 = 20,
    ///< Compute device class 2.1
    CU_TARGET_COMPUTE_21 = 21,
    ///< Compute device class 3.0
    CU_TARGET_COMPUTE_30 = 30,
    ///< Compute device class 3.2
    CU_TARGET_COMPUTE_32 = 32,
    ///< Compute device class 3.5
    CU_TARGET_COMPUTE_35 = 35,
    ///< Compute device class 3.7
    CU_TARGET_COMPUTE_37 = 37,
    ///< Compute device class 5.0
    CU_TARGET_COMPUTE_50 = 50,
    ///< Compute device class 5.2
    CU_TARGET_COMPUTE_52 = 52,
    ///< Compute device class 5.3
    CU_TARGET_COMPUTE_53 = 53,
    ///< Compute device class 6.0.
    CU_TARGET_COMPUTE_60 = 60,
    ///< Compute device class 6.1.
    CU_TARGET_COMPUTE_61 = 61,
    ///< Compute device class 6.2.
    CU_TARGET_COMPUTE_62 = 62,
    ///< Compute device class 7.0.
    CU_TARGET_COMPUTE_70 = 70,
    ///< Compute device class 7.5.
    CU_TARGET_COMPUTE_75 = 75,
}
pub use self::CUjit_target_enum as CUjit_target;
#[repr(i32)]
/// Cubin matching fallback strategies
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CUjit_fallback_enum {
    ///< Prefer to compile ptx if exact binary match not found
    CU_PREFER_PTX = 0,
    ///< Prefer to fall back to compatible binary code if exact match not found
    CU_PREFER_BINARY = 1,
}
pub use self::CUjit_fallback_enum as CUjit_fallback;
#[repr(i32)]
/// Caching modes for dlcm
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CUjit_cacheMode_enum {
    ///< Compile with no -dlcm flag specified
    CU_JIT_CACHE_OPTION_NONE = 0,
    ///< Compile with L1 cache disabled
    CU_JIT_CACHE_OPTION_CG = 1,
    ///< Compile with L1 cache enabled
    CU_JIT_CACHE_OPTION_CA = 2,
}
pub use self::CUjit_cacheMode_enum as CUjit_cacheMode;
#[repr(i32)]
/// Device code formats
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CUjitInputType_enum {
    /// Compiled device-class-specific device code\n
    /// Applicable options: none
    CU_JIT_INPUT_CUBIN = 0,
    /// PTX source code\n
    /// Applicable options: PTX compiler options
    CU_JIT_INPUT_PTX = 1,
    /// Bundle of multiple cubins and/or PTX of some device code\n
    /// Applicable options: PTX compiler options, ::CU_JIT_FALLBACK_STRATEGY
    CU_JIT_INPUT_FATBINARY = 2,
    /// Host object with embedded device code\n
    /// Applicable options: PTX compiler options, ::CU_JIT_FALLBACK_STRATEGY
    CU_JIT_INPUT_OBJECT = 3,
    /// Archive of host objects with embedded device code\n
    /// Applicable options: PTX compiler options, ::CU_JIT_FALLBACK_STRATEGY
    CU_JIT_INPUT_LIBRARY = 4,
    /// Archive of host objects with embedded device code\n
    /// Applicable options: PTX compiler options, ::CU_JIT_FALLBACK_STRATEGY
    CU_JIT_NUM_INPUT_TYPES = 5,
}
pub use self::CUjitInputType_enum as CUjitInputType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUlinkState_st {
    _unused: [u8; 0],
}
pub type CUlinkState = *mut CUlinkState_st;
#[repr(i32)]
/// Flags to register a graphics resource
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CUgraphicsRegisterFlags_enum {
    CU_GRAPHICS_REGISTER_FLAGS_NONE = 0,
    CU_GRAPHICS_REGISTER_FLAGS_READ_ONLY = 1,
    CU_GRAPHICS_REGISTER_FLAGS_WRITE_DISCARD = 2,
    CU_GRAPHICS_REGISTER_FLAGS_SURFACE_LDST = 4,
    CU_GRAPHICS_REGISTER_FLAGS_TEXTURE_GATHER = 8,
}
pub use self::CUgraphicsRegisterFlags_enum as CUgraphicsRegisterFlags;
#[repr(i32)]
/// Flags for mapping and unmapping interop resources
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CUgraphicsMapResourceFlags_enum {
    CU_GRAPHICS_MAP_RESOURCE_FLAGS_NONE = 0,
    CU_GRAPHICS_MAP_RESOURCE_FLAGS_READ_ONLY = 1,
    CU_GRAPHICS_MAP_RESOURCE_FLAGS_WRITE_DISCARD = 2,
}
pub use self::CUgraphicsMapResourceFlags_enum as CUgraphicsMapResourceFlags;
#[repr(i32)]
/// Array indices for cube faces
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CUarray_cubemap_face_enum {
    ///< Positive X face of cubemap
    CU_CUBEMAP_FACE_POSITIVE_X = 0,
    ///< Negative X face of cubemap
    CU_CUBEMAP_FACE_NEGATIVE_X = 1,
    ///< Positive Y face of cubemap
    CU_CUBEMAP_FACE_POSITIVE_Y = 2,
    ///< Negative Y face of cubemap
    CU_CUBEMAP_FACE_NEGATIVE_Y = 3,
    ///< Positive Z face of cubemap
    CU_CUBEMAP_FACE_POSITIVE_Z = 4,
    ///< Negative Z face of cubemap
    CU_CUBEMAP_FACE_NEGATIVE_Z = 5,
}
pub use self::CUarray_cubemap_face_enum as CUarray_cubemap_face;
#[repr(i32)]
/// Limits
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CUlimit_enum {
    ///< GPU thread stack size
    CU_LIMIT_STACK_SIZE = 0,
    ///< GPU printf FIFO size
    CU_LIMIT_PRINTF_FIFO_SIZE = 1,
    ///< GPU malloc heap size
    CU_LIMIT_MALLOC_HEAP_SIZE = 2,
    ///< GPU device runtime launch synchronize depth
    CU_LIMIT_DEV_RUNTIME_SYNC_DEPTH = 3,
    ///< GPU device runtime pending launch count
    CU_LIMIT_DEV_RUNTIME_PENDING_LAUNCH_COUNT = 4,
    ///< A value between 0 and 128 that indicates the maximum fetch granularity of L2 (in Bytes). This is a hint
    CU_LIMIT_MAX_L2_FETCH_GRANULARITY = 5,
    CU_LIMIT_MAX = 6,
}
pub use self::CUlimit_enum as CUlimit;
#[repr(i32)]
/// Resource types
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CUresourcetype_enum {
    ///< Array resoure
    CU_RESOURCE_TYPE_ARRAY = 0,
    ///< Mipmapped array resource
    CU_RESOURCE_TYPE_MIPMAPPED_ARRAY = 1,
    ///< Linear resource
    CU_RESOURCE_TYPE_LINEAR = 2,
    ///< Pitch 2D resource
    CU_RESOURCE_TYPE_PITCH2D = 3,
}
pub use self::CUresourcetype_enum as CUresourcetype;
/// CUDA host function
/// \param userData Argument value passed to the function
pub type CUhostFn =
    ::std::option::Option<unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void)>;
/// GPU kernel node parameters
#[repr(C)]
pub struct CUDA_KERNEL_NODE_PARAMS_st {
    ///< Kernel to launch
    pub func: CUfunction,
    ///< Width of grid in blocks
    pub gridDimX: ::std::os::raw::c_uint,
    ///< Height of grid in blocks
    pub gridDimY: ::std::os::raw::c_uint,
    ///< Depth of grid in blocks
    pub gridDimZ: ::std::os::raw::c_uint,
    ///< X dimension of each thread block
    pub blockDimX: ::std::os::raw::c_uint,
    ///< Y dimension of each thread block
    pub blockDimY: ::std::os::raw::c_uint,
    ///< Z dimension of each thread block
    pub blockDimZ: ::std::os::raw::c_uint,
    ///< Dynamic shared-memory size per thread block in bytes
    pub sharedMemBytes: ::std::os::raw::c_uint,
    ///< Array of pointers to kernel parameters
    pub kernelParams: *mut *mut ::std::os::raw::c_void,
    ///< Extra options
    pub extra: *mut *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_CUDA_KERNEL_NODE_PARAMS_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_KERNEL_NODE_PARAMS_st>(),
        56usize,
        concat!("Size of: ", stringify!(CUDA_KERNEL_NODE_PARAMS_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_KERNEL_NODE_PARAMS_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_KERNEL_NODE_PARAMS_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_KERNEL_NODE_PARAMS_st>())).func as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_st),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_KERNEL_NODE_PARAMS_st>())).gridDimX as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_st),
            "::",
            stringify!(gridDimX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_KERNEL_NODE_PARAMS_st>())).gridDimY as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_st),
            "::",
            stringify!(gridDimY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_KERNEL_NODE_PARAMS_st>())).gridDimZ as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_st),
            "::",
            stringify!(gridDimZ)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_KERNEL_NODE_PARAMS_st>())).blockDimX as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_st),
            "::",
            stringify!(blockDimX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_KERNEL_NODE_PARAMS_st>())).blockDimY as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_st),
            "::",
            stringify!(blockDimY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_KERNEL_NODE_PARAMS_st>())).blockDimZ as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_st),
            "::",
            stringify!(blockDimZ)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_KERNEL_NODE_PARAMS_st>())).sharedMemBytes as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_st),
            "::",
            stringify!(sharedMemBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_KERNEL_NODE_PARAMS_st>())).kernelParams as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_st),
            "::",
            stringify!(kernelParams)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_KERNEL_NODE_PARAMS_st>())).extra as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_st),
            "::",
            stringify!(extra)
        )
    );
}
pub type CUDA_KERNEL_NODE_PARAMS = CUDA_KERNEL_NODE_PARAMS_st;
/// Memset node parameters
#[repr(C)]
pub struct CUDA_MEMSET_NODE_PARAMS_st {
    ///< Destination device pointer
    pub dst: CUdeviceptr,
    ///< Pitch of destination device pointer. Unused if height is 1
    pub pitch: usize,
    ///< Value to be set
    pub value: ::std::os::raw::c_uint,
    ///< Size of each element in bytes. Must be 1, 2, or 4.
    pub elementSize: ::std::os::raw::c_uint,
    ///< Width in bytes, of the row
    pub width: usize,
    ///< Number of rows
    pub height: usize,
}
#[test]
fn bindgen_test_layout_CUDA_MEMSET_NODE_PARAMS_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_MEMSET_NODE_PARAMS_st>(),
        40usize,
        concat!("Size of: ", stringify!(CUDA_MEMSET_NODE_PARAMS_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_MEMSET_NODE_PARAMS_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_MEMSET_NODE_PARAMS_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMSET_NODE_PARAMS_st>())).dst as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMSET_NODE_PARAMS_st),
            "::",
            stringify!(dst)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_MEMSET_NODE_PARAMS_st>())).pitch as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMSET_NODE_PARAMS_st),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_MEMSET_NODE_PARAMS_st>())).value as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMSET_NODE_PARAMS_st),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_MEMSET_NODE_PARAMS_st>())).elementSize as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMSET_NODE_PARAMS_st),
            "::",
            stringify!(elementSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_MEMSET_NODE_PARAMS_st>())).width as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMSET_NODE_PARAMS_st),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_MEMSET_NODE_PARAMS_st>())).height as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMSET_NODE_PARAMS_st),
            "::",
            stringify!(height)
        )
    );
}
pub type CUDA_MEMSET_NODE_PARAMS = CUDA_MEMSET_NODE_PARAMS_st;
/// Host node parameters
#[repr(C)]
pub struct CUDA_HOST_NODE_PARAMS_st {
    ///< The function to call when the node executes
    pub fn_: CUhostFn,
    ///< Argument to pass to the function
    pub userData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_CUDA_HOST_NODE_PARAMS_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_HOST_NODE_PARAMS_st>(),
        16usize,
        concat!("Size of: ", stringify!(CUDA_HOST_NODE_PARAMS_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_HOST_NODE_PARAMS_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_HOST_NODE_PARAMS_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_HOST_NODE_PARAMS_st>())).fn_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_HOST_NODE_PARAMS_st),
            "::",
            stringify!(fn_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_HOST_NODE_PARAMS_st>())).userData as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_HOST_NODE_PARAMS_st),
            "::",
            stringify!(userData)
        )
    );
}
pub type CUDA_HOST_NODE_PARAMS = CUDA_HOST_NODE_PARAMS_st;
#[repr(i32)]
/// Graph node types
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CUgraphNodeType_enum {
    ///< GPU kernel node
    CU_GRAPH_NODE_TYPE_KERNEL = 0,
    ///< Memcpy node
    CU_GRAPH_NODE_TYPE_MEMCPY = 1,
    ///< Memset node
    CU_GRAPH_NODE_TYPE_MEMSET = 2,
    ///< Host (executable) node
    CU_GRAPH_NODE_TYPE_HOST = 3,
    ///< Node which executes an embedded graph
    CU_GRAPH_NODE_TYPE_GRAPH = 4,
    ///< Empty (no-op) node
    CU_GRAPH_NODE_TYPE_EMPTY = 5,
    CU_GRAPH_NODE_TYPE_COUNT = 6,
}
pub use self::CUgraphNodeType_enum as CUgraphNodeType;
#[repr(i32)]
/// Possible stream capture statuses returned by ::cuStreamIsCapturing
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CUstreamCaptureStatus_enum {
    ///< Stream is not capturing
    CU_STREAM_CAPTURE_STATUS_NONE = 0,
    ///< Stream is actively capturing
    CU_STREAM_CAPTURE_STATUS_ACTIVE = 1,
    ///< Stream is part of a capture sequence that
    ///has been invalidated, but not terminated
    CU_STREAM_CAPTURE_STATUS_INVALIDATED = 2,
}
pub use self::CUstreamCaptureStatus_enum as CUstreamCaptureStatus;
#[repr(i32)]
/// Error codes
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum cudaError_enum {
    /// The API call returned with no errors. In the case of query calls, this
    /// also means that the operation being queried is complete (see
    /// ::cuEventQuery() and ::cuStreamQuery()).
    CUDA_SUCCESS = 0,
    /// This indicates that one or more of the parameters passed to the API call
    /// is not within an acceptable range of values.
    CUDA_ERROR_INVALID_VALUE = 1,
    /// The API call failed because it was unable to allocate enough memory to
    /// perform the requested operation.
    CUDA_ERROR_OUT_OF_MEMORY = 2,
    /// This indicates that the CUDA driver has not been initialized with
    /// ::cuInit() or that initialization has failed.
    CUDA_ERROR_NOT_INITIALIZED = 3,
    /// This indicates that the CUDA driver is in the process of shutting down.
    CUDA_ERROR_DEINITIALIZED = 4,
    /// This indicates profiler is not initialized for this run. This can
    /// happen when the application is running with external profiling tools
    /// like visual profiler.
    CUDA_ERROR_PROFILER_DISABLED = 5,
    /// \deprecated
    /// This error return is deprecated as of CUDA 5.0. It is no longer an error
    /// to attempt to enable/disable the profiling via ::cuProfilerStart or
    /// ::cuProfilerStop without initialization.
    CUDA_ERROR_PROFILER_NOT_INITIALIZED = 6,
    /// \deprecated
    /// This error return is deprecated as of CUDA 5.0. It is no longer an error
    /// to call cuProfilerStart() when profiling is already enabled.
    CUDA_ERROR_PROFILER_ALREADY_STARTED = 7,
    /// \deprecated
    /// This error return is deprecated as of CUDA 5.0. It is no longer an error
    /// to call cuProfilerStop() when profiling is already disabled.
    CUDA_ERROR_PROFILER_ALREADY_STOPPED = 8,
    /// This indicates that no CUDA-capable devices were detected by the installed
    /// CUDA driver.
    CUDA_ERROR_NO_DEVICE = 100,
    /// This indicates that the device ordinal supplied by the user does not
    /// correspond to a valid CUDA device.
    CUDA_ERROR_INVALID_DEVICE = 101,
    /// This indicates that the device kernel image is invalid. This can also
    /// indicate an invalid CUDA module.
    CUDA_ERROR_INVALID_IMAGE = 200,
    /// This most frequently indicates that there is no context bound to the
    /// current thread. This can also be returned if the context passed to an
    /// API call is not a valid handle (such as a context that has had
    /// ::cuCtxDestroy() invoked on it). This can also be returned if a user
    /// mixes different API versions (i.e. 3010 context with 3020 API calls).
    /// See ::cuCtxGetApiVersion() for more details.
    CUDA_ERROR_INVALID_CONTEXT = 201,
    /// This indicated that the context being supplied as a parameter to the
    /// API call was already the active context.
    /// \deprecated
    /// This error return is deprecated as of CUDA 3.2. It is no longer an
    /// error to attempt to push the active context via ::cuCtxPushCurrent().
    CUDA_ERROR_CONTEXT_ALREADY_CURRENT = 202,
    /// This indicates that a map or register operation has failed.
    CUDA_ERROR_MAP_FAILED = 205,
    /// This indicates that an unmap or unregister operation has failed.
    CUDA_ERROR_UNMAP_FAILED = 206,
    /// This indicates that the specified array is currently mapped and thus
    /// cannot be destroyed.
    CUDA_ERROR_ARRAY_IS_MAPPED = 207,
    /// This indicates that the resource is already mapped.
    CUDA_ERROR_ALREADY_MAPPED = 208,
    /// This indicates that there is no kernel image available that is suitable
    /// for the device. This can occur when a user specifies code generation
    /// options for a particular CUDA source file that do not include the
    /// corresponding device configuration.
    CUDA_ERROR_NO_BINARY_FOR_GPU = 209,
    /// This indicates that a resource has already been acquired.
    CUDA_ERROR_ALREADY_ACQUIRED = 210,
    /// This indicates that a resource is not mapped.
    CUDA_ERROR_NOT_MAPPED = 211,
    /// This indicates that a mapped resource is not available for access as an
    /// array.
    CUDA_ERROR_NOT_MAPPED_AS_ARRAY = 212,
    /// This indicates that a mapped resource is not available for access as a
    /// pointer.
    CUDA_ERROR_NOT_MAPPED_AS_POINTER = 213,
    /// This indicates that an uncorrectable ECC error was detected during
    /// execution.
    CUDA_ERROR_ECC_UNCORRECTABLE = 214,
    /// This indicates that the ::CUlimit passed to the API call is not
    /// supported by the active device.
    CUDA_ERROR_UNSUPPORTED_LIMIT = 215,
    /// This indicates that the ::CUcontext passed to the API call can
    /// only be bound to a single CPU thread at a time but is already
    /// bound to a CPU thread.
    CUDA_ERROR_CONTEXT_ALREADY_IN_USE = 216,
    /// This indicates that peer access is not supported across the given
    /// devices.
    CUDA_ERROR_PEER_ACCESS_UNSUPPORTED = 217,
    /// This indicates that a PTX JIT compilation failed.
    CUDA_ERROR_INVALID_PTX = 218,
    /// This indicates an error with OpenGL or DirectX context.
    CUDA_ERROR_INVALID_GRAPHICS_CONTEXT = 219,
    /// This indicates that an uncorrectable NVLink error was detected during the
    /// execution.
    CUDA_ERROR_NVLINK_UNCORRECTABLE = 220,
    /// This indicates that the PTX JIT compiler library was not found.
    CUDA_ERROR_JIT_COMPILER_NOT_FOUND = 221,
    /// This indicates that the device kernel source is invalid.
    CUDA_ERROR_INVALID_SOURCE = 300,
    /// This indicates that the file specified was not found.
    CUDA_ERROR_FILE_NOT_FOUND = 301,
    /// This indicates that a link to a shared object failed to resolve.
    CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND = 302,
    /// This indicates that initialization of a shared object failed.
    CUDA_ERROR_SHARED_OBJECT_INIT_FAILED = 303,
    /// This indicates that an OS call failed.
    CUDA_ERROR_OPERATING_SYSTEM = 304,
    /// This indicates that a resource handle passed to the API call was not
    /// valid. Resource handles are opaque types like ::CUstream and ::CUevent.
    CUDA_ERROR_INVALID_HANDLE = 400,
    /// This indicates that a resource required by the API call is not in a
    /// valid state to perform the requested operation.
    CUDA_ERROR_ILLEGAL_STATE = 401,
    /// This indicates that a named symbol was not found. Examples of symbols
    /// are global/constant variable names, texture names, and surface names.
    CUDA_ERROR_NOT_FOUND = 500,
    /// This indicates that asynchronous operations issued previously have not
    /// completed yet. This result is not actually an error, but must be indicated
    /// differently than ::CUDA_SUCCESS (which indicates completion). Calls that
    /// may return this value include ::cuEventQuery() and ::cuStreamQuery().
    CUDA_ERROR_NOT_READY = 600,
    /// While executing a kernel, the device encountered a
    /// load or store instruction on an invalid memory address.
    /// This leaves the process in an inconsistent state and any further CUDA work
    /// will return the same error. To continue using CUDA, the process must be terminated
    /// and relaunched.
    CUDA_ERROR_ILLEGAL_ADDRESS = 700,
    /// This indicates that a launch did not occur because it did not have
    /// appropriate resources. This error usually indicates that the user has
    /// attempted to pass too many arguments to the device kernel, or the
    /// kernel launch specifies too many threads for the kernel's register
    /// count. Passing arguments of the wrong size (i.e. a 64-bit pointer
    /// when a 32-bit int is expected) is equivalent to passing too many
    /// arguments and can also result in this error.
    CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES = 701,
    /// This indicates that the device kernel took too long to execute. This can
    /// only occur if timeouts are enabled - see the device attribute
    /// ::CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT for more information.
    /// This leaves the process in an inconsistent state and any further CUDA work
    /// will return the same error. To continue using CUDA, the process must be terminated
    /// and relaunched.
    CUDA_ERROR_LAUNCH_TIMEOUT = 702,
    /// This error indicates a kernel launch that uses an incompatible texturing
    /// mode.
    CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING = 703,
    /// This error indicates that a call to ::cuCtxEnablePeerAccess() is
    /// trying to re-enable peer access to a context which has already
    /// had peer access to it enabled.
    CUDA_ERROR_PEER_ACCESS_ALREADY_ENABLED = 704,
    /// This error indicates that ::cuCtxDisablePeerAccess() is
    /// trying to disable peer access which has not been enabled yet
    /// via ::cuCtxEnablePeerAccess().
    CUDA_ERROR_PEER_ACCESS_NOT_ENABLED = 705,
    /// This error indicates that the primary context for the specified device
    /// has already been initialized.
    CUDA_ERROR_PRIMARY_CONTEXT_ACTIVE = 708,
    /// This error indicates that the context current to the calling thread
    /// has been destroyed using ::cuCtxDestroy, or is a primary context which
    /// has not yet been initialized.
    CUDA_ERROR_CONTEXT_IS_DESTROYED = 709,
    /// A device-side assert triggered during kernel execution. The context
    /// cannot be used anymore, and must be destroyed. All existing device
    /// memory allocations from this context are invalid and must be
    /// reconstructed if the program is to continue using CUDA.
    CUDA_ERROR_ASSERT = 710,
    /// This error indicates that the hardware resources required to enable
    /// peer access have been exhausted for one or more of the devices
    /// passed to ::cuCtxEnablePeerAccess().
    CUDA_ERROR_TOO_MANY_PEERS = 711,
    /// This error indicates that the memory range passed to ::cuMemHostRegister()
    /// has already been registered.
    CUDA_ERROR_HOST_MEMORY_ALREADY_REGISTERED = 712,
    /// This error indicates that the pointer passed to ::cuMemHostUnregister()
    /// does not correspond to any currently registered memory region.
    CUDA_ERROR_HOST_MEMORY_NOT_REGISTERED = 713,
    /// While executing a kernel, the device encountered a stack error.
    /// This can be due to stack corruption or exceeding the stack size limit.
    /// This leaves the process in an inconsistent state and any further CUDA work
    /// will return the same error. To continue using CUDA, the process must be terminated
    /// and relaunched.
    CUDA_ERROR_HARDWARE_STACK_ERROR = 714,
    /// While executing a kernel, the device encountered an illegal instruction.
    /// This leaves the process in an inconsistent state and any further CUDA work
    /// will return the same error. To continue using CUDA, the process must be terminated
    /// and relaunched.
    CUDA_ERROR_ILLEGAL_INSTRUCTION = 715,
    /// While executing a kernel, the device encountered a load or store instruction
    /// on a memory address which is not aligned.
    /// This leaves the process in an inconsistent state and any further CUDA work
    /// will return the same error. To continue using CUDA, the process must be terminated
    /// and relaunched.
    CUDA_ERROR_MISALIGNED_ADDRESS = 716,
    /// While executing a kernel, the device encountered an instruction
    /// which can only operate on memory locations in certain address spaces
    /// (global, shared, or local), but was supplied a memory address not
    /// belonging to an allowed address space.
    /// This leaves the process in an inconsistent state and any further CUDA work
    /// will return the same error. To continue using CUDA, the process must be terminated
    /// and relaunched.
    CUDA_ERROR_INVALID_ADDRESS_SPACE = 717,
    /// While executing a kernel, the device program counter wrapped its address space.
    /// This leaves the process in an inconsistent state and any further CUDA work
    /// will return the same error. To continue using CUDA, the process must be terminated
    /// and relaunched.
    CUDA_ERROR_INVALID_PC = 718,
    /// An exception occurred on the device while executing a kernel. Common
    /// causes include dereferencing an invalid device pointer and accessing
    /// out of bounds shared memory.
    /// This leaves the process in an inconsistent state and any further CUDA work
    /// will return the same error. To continue using CUDA, the process must be terminated
    /// and relaunched.
    CUDA_ERROR_LAUNCH_FAILED = 719,
    /// This error indicates that the number of blocks launched per grid for a kernel that was
    /// launched via either ::cuLaunchCooperativeKernel or ::cuLaunchCooperativeKernelMultiDevice
    /// exceeds the maximum number of blocks as allowed by ::cuOccupancyMaxActiveBlocksPerMultiprocessor
    /// or ::cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags times the number of multiprocessors
    /// as specified by the device attribute ::CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT.
    CUDA_ERROR_COOPERATIVE_LAUNCH_TOO_LARGE = 720,
    /// This error indicates that the attempted operation is not permitted.
    CUDA_ERROR_NOT_PERMITTED = 800,
    /// This error indicates that the attempted operation is not supported
    /// on the current system or device.
    CUDA_ERROR_NOT_SUPPORTED = 801,
    /// This error indicates that the system is not yet ready to start any CUDA
    /// work.  To continue using CUDA, verify the system configuration is in a
    /// valid state and all required driver daemons are actively running.
    CUDA_ERROR_SYSTEM_NOT_READY = 802,
    /// This error indicates that the operation is not permitted when
    /// the stream is capturing.
    CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED = 900,
    /// This error indicates that the current capture sequence on the stream
    /// has been invalidated due to a previous error.
    CUDA_ERROR_STREAM_CAPTURE_INVALIDATED = 901,
    /// This error indicates that the operation would have resulted in a merge
    /// of two independent capture sequences.
    CUDA_ERROR_STREAM_CAPTURE_MERGE = 902,
    /// This error indicates that the capture was not initiated in this stream.
    CUDA_ERROR_STREAM_CAPTURE_UNMATCHED = 903,
    /// This error indicates that the capture sequence contains a fork that was
    /// not joined to the primary stream.
    CUDA_ERROR_STREAM_CAPTURE_UNJOINED = 904,
    /// This error indicates that a dependency would have been created which
    /// crosses the capture sequence boundary. Only implicit in-stream ordering
    /// dependencies are allowed to cross the boundary.
    CUDA_ERROR_STREAM_CAPTURE_ISOLATION = 905,
    /// This error indicates a disallowed implicit dependency on a current capture
    /// sequence from cudaStreamLegacy.
    CUDA_ERROR_STREAM_CAPTURE_IMPLICIT = 906,
    /// This error indicates that the operation is not permitted on an event which
    /// was last recorded in a capturing stream.
    CUDA_ERROR_CAPTURED_EVENT = 907,
    /// This indicates that an unknown internal error has occurred.
    CUDA_ERROR_UNKNOWN = 999,
}
pub use self::cudaError_enum as CUresult;
impl CUdevice_P2PAttribute_enum {
    pub const CU_DEVICE_P2P_ATTRIBUTE_CUDA_ARRAY_ACCESS_SUPPORTED: CUdevice_P2PAttribute_enum =
        CUdevice_P2PAttribute_enum::CU_DEVICE_P2P_ATTRIBUTE_ARRAY_ACCESS_ACCESS_SUPPORTED;
}
#[repr(i32)]
/// P2P Attributes
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CUdevice_P2PAttribute_enum {
    ///< A relative value indicating the performance of the link between two devices
    CU_DEVICE_P2P_ATTRIBUTE_PERFORMANCE_RANK = 1,
    ///< P2P Access is enable
    CU_DEVICE_P2P_ATTRIBUTE_ACCESS_SUPPORTED = 2,
    ///< Atomic operation over the link supported
    CU_DEVICE_P2P_ATTRIBUTE_NATIVE_ATOMIC_SUPPORTED = 3,
    ///< \deprecated use CU_DEVICE_P2P_ATTRIBUTE_CUDA_ARRAY_ACCESS_SUPPORTED instead
    CU_DEVICE_P2P_ATTRIBUTE_ARRAY_ACCESS_ACCESS_SUPPORTED = 4,
}
pub use self::CUdevice_P2PAttribute_enum as CUdevice_P2PAttribute;
/// CUDA stream callback
/// \param hStream The stream the callback was added to, as passed to ::cuStreamAddCallback.  May be NULL.
/// \param status ::CUDA_SUCCESS or any persistent error on the stream.
/// \param userData User parameter provided at registration.
pub type CUstreamCallback = ::std::option::Option<
    unsafe extern "C" fn(
        hStream: CUstream,
        status: CUresult,
        userData: *mut ::std::os::raw::c_void,
    ),
>;
/// Block size to per-block dynamic shared memory mapping for a certain
/// kernel \param blockSize Block size of the kernel.
///
/// \return The dynamic shared memory needed by a block.
pub type CUoccupancyB2DSize =
    ::std::option::Option<unsafe extern "C" fn(blockSize: ::std::os::raw::c_int) -> usize>;
/// 2D memory copy parameters
#[repr(C)]
pub struct CUDA_MEMCPY2D_st {
    ///< Source X in bytes
    pub srcXInBytes: usize,
    ///< Source Y
    pub srcY: usize,
    ///< Source memory type (host, device, array)
    pub srcMemoryType: CUmemorytype,
    ///< Source host pointer
    pub srcHost: *const ::std::os::raw::c_void,
    ///< Source device pointer
    pub srcDevice: CUdeviceptr,
    ///< Source array reference
    pub srcArray: CUarray,
    ///< Source pitch (ignored when src is array)
    pub srcPitch: usize,
    ///< Destination X in bytes
    pub dstXInBytes: usize,
    ///< Destination Y
    pub dstY: usize,
    ///< Destination memory type (host, device, array)
    pub dstMemoryType: CUmemorytype,
    ///< Destination host pointer
    pub dstHost: *mut ::std::os::raw::c_void,
    ///< Destination device pointer
    pub dstDevice: CUdeviceptr,
    ///< Destination array reference
    pub dstArray: CUarray,
    ///< Destination pitch (ignored when dst is array)
    pub dstPitch: usize,
    ///< Width of 2D memory copy in bytes
    pub WidthInBytes: usize,
    ///< Height of 2D memory copy
    pub Height: usize,
}
#[test]
fn bindgen_test_layout_CUDA_MEMCPY2D_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_MEMCPY2D_st>(),
        128usize,
        concat!("Size of: ", stringify!(CUDA_MEMCPY2D_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_MEMCPY2D_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_MEMCPY2D_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY2D_st>())).srcXInBytes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(srcXInBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY2D_st>())).srcY as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(srcY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY2D_st>())).srcMemoryType as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(srcMemoryType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY2D_st>())).srcHost as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(srcHost)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY2D_st>())).srcDevice as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(srcDevice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY2D_st>())).srcArray as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(srcArray)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY2D_st>())).srcPitch as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(srcPitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY2D_st>())).dstXInBytes as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(dstXInBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY2D_st>())).dstY as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(dstY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY2D_st>())).dstMemoryType as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(dstMemoryType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY2D_st>())).dstHost as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(dstHost)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY2D_st>())).dstDevice as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(dstDevice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY2D_st>())).dstArray as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(dstArray)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY2D_st>())).dstPitch as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(dstPitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY2D_st>())).WidthInBytes as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(WidthInBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY2D_st>())).Height as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(Height)
        )
    );
}
pub type CUDA_MEMCPY2D = CUDA_MEMCPY2D_st;
/// 3D memory copy parameters
#[repr(C)]
pub struct CUDA_MEMCPY3D_st {
    ///< Source X in bytes
    pub srcXInBytes: usize,
    ///< Source Y
    pub srcY: usize,
    ///< Source Z
    pub srcZ: usize,
    ///< Source LOD
    pub srcLOD: usize,
    ///< Source memory type (host, device, array)
    pub srcMemoryType: CUmemorytype,
    ///< Source host pointer
    pub srcHost: *const ::std::os::raw::c_void,
    ///< Source device pointer
    pub srcDevice: CUdeviceptr,
    ///< Source array reference
    pub srcArray: CUarray,
    ///< Must be NULL
    pub reserved0: *mut ::std::os::raw::c_void,
    ///< Source pitch (ignored when src is array)
    pub srcPitch: usize,
    ///< Source height (ignored when src is array; may be 0 if Depth==1)
    pub srcHeight: usize,
    ///< Destination X in bytes
    pub dstXInBytes: usize,
    ///< Destination Y
    pub dstY: usize,
    ///< Destination Z
    pub dstZ: usize,
    ///< Destination LOD
    pub dstLOD: usize,
    ///< Destination memory type (host, device, array)
    pub dstMemoryType: CUmemorytype,
    ///< Destination host pointer
    pub dstHost: *mut ::std::os::raw::c_void,
    ///< Destination device pointer
    pub dstDevice: CUdeviceptr,
    ///< Destination array reference
    pub dstArray: CUarray,
    ///< Must be NULL
    pub reserved1: *mut ::std::os::raw::c_void,
    ///< Destination pitch (ignored when dst is array)
    pub dstPitch: usize,
    ///< Destination height (ignored when dst is array; may be 0 if Depth==1)
    pub dstHeight: usize,
    ///< Width of 3D memory copy in bytes
    pub WidthInBytes: usize,
    ///< Height of 3D memory copy
    pub Height: usize,
    ///< Depth of 3D memory copy
    pub Depth: usize,
}
#[test]
fn bindgen_test_layout_CUDA_MEMCPY3D_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_MEMCPY3D_st>(),
        200usize,
        concat!("Size of: ", stringify!(CUDA_MEMCPY3D_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_MEMCPY3D_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_MEMCPY3D_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).srcXInBytes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(srcXInBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).srcY as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(srcY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).srcZ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(srcZ)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).srcLOD as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(srcLOD)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).srcMemoryType as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(srcMemoryType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).srcHost as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(srcHost)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).srcDevice as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(srcDevice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).srcArray as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(srcArray)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).reserved0 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).srcPitch as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(srcPitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).srcHeight as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(srcHeight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).dstXInBytes as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(dstXInBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).dstY as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(dstY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).dstZ as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(dstZ)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).dstLOD as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(dstLOD)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).dstMemoryType as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(dstMemoryType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).dstHost as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(dstHost)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).dstDevice as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(dstDevice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).dstArray as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(dstArray)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).reserved1 as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).dstPitch as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(dstPitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).dstHeight as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(dstHeight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).WidthInBytes as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(WidthInBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).Height as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(Height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).Depth as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(Depth)
        )
    );
}
pub type CUDA_MEMCPY3D = CUDA_MEMCPY3D_st;
/// 3D memory cross-context copy parameters
#[repr(C)]
pub struct CUDA_MEMCPY3D_PEER_st {
    ///< Source X in bytes
    pub srcXInBytes: usize,
    ///< Source Y
    pub srcY: usize,
    ///< Source Z
    pub srcZ: usize,
    ///< Source LOD
    pub srcLOD: usize,
    ///< Source memory type (host, device, array)
    pub srcMemoryType: CUmemorytype,
    ///< Source host pointer
    pub srcHost: *const ::std::os::raw::c_void,
    ///< Source device pointer
    pub srcDevice: CUdeviceptr,
    ///< Source array reference
    pub srcArray: CUarray,
    ///< Source context (ignored with srcMemoryType is ::CU_MEMORYTYPE_ARRAY)
    pub srcContext: CUcontext,
    ///< Source pitch (ignored when src is array)
    pub srcPitch: usize,
    ///< Source height (ignored when src is array; may be 0 if Depth==1)
    pub srcHeight: usize,
    ///< Destination X in bytes
    pub dstXInBytes: usize,
    ///< Destination Y
    pub dstY: usize,
    ///< Destination Z
    pub dstZ: usize,
    ///< Destination LOD
    pub dstLOD: usize,
    ///< Destination memory type (host, device, array)
    pub dstMemoryType: CUmemorytype,
    ///< Destination host pointer
    pub dstHost: *mut ::std::os::raw::c_void,
    ///< Destination device pointer
    pub dstDevice: CUdeviceptr,
    ///< Destination array reference
    pub dstArray: CUarray,
    ///< Destination context (ignored with dstMemoryType is ::CU_MEMORYTYPE_ARRAY)
    pub dstContext: CUcontext,
    ///< Destination pitch (ignored when dst is array)
    pub dstPitch: usize,
    ///< Destination height (ignored when dst is array; may be 0 if Depth==1)
    pub dstHeight: usize,
    ///< Width of 3D memory copy in bytes
    pub WidthInBytes: usize,
    ///< Height of 3D memory copy
    pub Height: usize,
    ///< Depth of 3D memory copy
    pub Depth: usize,
}
#[test]
fn bindgen_test_layout_CUDA_MEMCPY3D_PEER_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_MEMCPY3D_PEER_st>(),
        200usize,
        concat!("Size of: ", stringify!(CUDA_MEMCPY3D_PEER_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_MEMCPY3D_PEER_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_MEMCPY3D_PEER_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).srcXInBytes as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcXInBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).srcY as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).srcZ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcZ)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).srcLOD as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcLOD)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).srcMemoryType as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcMemoryType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).srcHost as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcHost)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).srcDevice as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcDevice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).srcArray as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcArray)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).srcContext as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcContext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).srcPitch as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcPitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).srcHeight as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcHeight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).dstXInBytes as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstXInBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).dstY as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).dstZ as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstZ)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).dstLOD as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstLOD)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).dstMemoryType as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstMemoryType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).dstHost as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstHost)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).dstDevice as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstDevice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).dstArray as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstArray)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).dstContext as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstContext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).dstPitch as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstPitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).dstHeight as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstHeight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).WidthInBytes as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(WidthInBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).Height as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(Height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).Depth as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(Depth)
        )
    );
}
pub type CUDA_MEMCPY3D_PEER = CUDA_MEMCPY3D_PEER_st;
/// Array descriptor
#[repr(C)]
pub struct CUDA_ARRAY_DESCRIPTOR_st {
    ///< Width of array
    pub Width: usize,
    ///< Height of array
    pub Height: usize,
    ///< Array format
    pub Format: CUarray_format,
    ///< Channels per array element
    pub NumChannels: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CUDA_ARRAY_DESCRIPTOR_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_ARRAY_DESCRIPTOR_st>(),
        24usize,
        concat!("Size of: ", stringify!(CUDA_ARRAY_DESCRIPTOR_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_ARRAY_DESCRIPTOR_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_ARRAY_DESCRIPTOR_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_ARRAY_DESCRIPTOR_st>())).Width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_DESCRIPTOR_st),
            "::",
            stringify!(Width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_ARRAY_DESCRIPTOR_st>())).Height as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_DESCRIPTOR_st),
            "::",
            stringify!(Height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_ARRAY_DESCRIPTOR_st>())).Format as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_DESCRIPTOR_st),
            "::",
            stringify!(Format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_ARRAY_DESCRIPTOR_st>())).NumChannels as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_DESCRIPTOR_st),
            "::",
            stringify!(NumChannels)
        )
    );
}
pub type CUDA_ARRAY_DESCRIPTOR = CUDA_ARRAY_DESCRIPTOR_st;
/// 3D array descriptor
#[repr(C)]
pub struct CUDA_ARRAY3D_DESCRIPTOR_st {
    ///< Width of 3D array
    pub Width: usize,
    ///< Height of 3D array
    pub Height: usize,
    ///< Depth of 3D array
    pub Depth: usize,
    ///< Array format
    pub Format: CUarray_format,
    ///< Channels per array element
    pub NumChannels: ::std::os::raw::c_uint,
    ///< Flags
    pub Flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CUDA_ARRAY3D_DESCRIPTOR_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_ARRAY3D_DESCRIPTOR_st>(),
        40usize,
        concat!("Size of: ", stringify!(CUDA_ARRAY3D_DESCRIPTOR_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_ARRAY3D_DESCRIPTOR_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_ARRAY3D_DESCRIPTOR_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_ARRAY3D_DESCRIPTOR_st>())).Width as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY3D_DESCRIPTOR_st),
            "::",
            stringify!(Width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_ARRAY3D_DESCRIPTOR_st>())).Height as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY3D_DESCRIPTOR_st),
            "::",
            stringify!(Height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_ARRAY3D_DESCRIPTOR_st>())).Depth as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY3D_DESCRIPTOR_st),
            "::",
            stringify!(Depth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_ARRAY3D_DESCRIPTOR_st>())).Format as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY3D_DESCRIPTOR_st),
            "::",
            stringify!(Format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_ARRAY3D_DESCRIPTOR_st>())).NumChannels as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY3D_DESCRIPTOR_st),
            "::",
            stringify!(NumChannels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_ARRAY3D_DESCRIPTOR_st>())).Flags as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY3D_DESCRIPTOR_st),
            "::",
            stringify!(Flags)
        )
    );
}
pub type CUDA_ARRAY3D_DESCRIPTOR = CUDA_ARRAY3D_DESCRIPTOR_st;
/// CUDA Resource descriptor
#[repr(C)]
pub struct CUDA_RESOURCE_DESC_st {
    ///< Resource type
    pub resType: CUresourcetype,
    pub res: CUDA_RESOURCE_DESC_st__bindgen_ty_1,
    ///< Flags (must be zero)
    pub flags: ::std::os::raw::c_uint,
}
#[repr(C)]
pub struct CUDA_RESOURCE_DESC_st__bindgen_ty_1 {
    pub array: __BindgenUnionField<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1>,
    pub mipmap: __BindgenUnionField<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2>,
    pub linear: __BindgenUnionField<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3>,
    pub pitch2D: __BindgenUnionField<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4>,
    pub reserved: __BindgenUnionField<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5>,
    pub bindgen_union_field: [u64; 16usize],
}
#[repr(C)]
pub struct CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1 {
    ///< CUDA array
    pub hArray: CUarray,
}
#[test]
fn bindgen_test_layout_CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1>())).hArray
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(hArray)
        )
    );
}
#[repr(C)]
pub struct CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2 {
    ///< CUDA mipmapped array
    pub hMipmappedArray: CUmipmappedArray,
}
#[test]
fn bindgen_test_layout_CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2>()))
                .hMipmappedArray as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(hMipmappedArray)
        )
    );
}
#[repr(C)]
pub struct CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3 {
    ///< Device pointer
    pub devPtr: CUdeviceptr,
    ///< Array format
    pub format: CUarray_format,
    ///< Channels per array element
    pub numChannels: ::std::os::raw::c_uint,
    ///< Size in bytes
    pub sizeInBytes: usize,
}
#[test]
fn bindgen_test_layout_CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3>())).devPtr
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(devPtr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3>())).format
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3>()))
                .numChannels as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(numChannels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3>()))
                .sizeInBytes as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(sizeInBytes)
        )
    );
}
#[repr(C)]
pub struct CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4 {
    ///< Device pointer
    pub devPtr: CUdeviceptr,
    ///< Array format
    pub format: CUarray_format,
    ///< Channels per array element
    pub numChannels: ::std::os::raw::c_uint,
    ///< Width of the array in elements
    pub width: usize,
    ///< Height of the array in elements
    pub height: usize,
    ///< Pitch between two rows in bytes
    pub pitchInBytes: usize,
}
#[test]
fn bindgen_test_layout_CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4>())).devPtr
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(devPtr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4>())).format
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4>()))
                .numChannels as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(numChannels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4>())).width
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4>())).height
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4>()))
                .pitchInBytes as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(pitchInBytes)
        )
    );
}
#[repr(C)]
pub struct CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5 {
    pub reserved: [::std::os::raw::c_int; 32usize],
}
#[test]
fn bindgen_test_layout_CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5>())).reserved
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_CUDA_RESOURCE_DESC_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1>(),
        128usize,
        concat!("Size of: ", stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st__bindgen_ty_1>())).array as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st__bindgen_ty_1>())).mipmap as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(mipmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st__bindgen_ty_1>())).linear as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(linear)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st__bindgen_ty_1>())).pitch2D as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(pitch2D)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st__bindgen_ty_1>())).reserved as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_CUDA_RESOURCE_DESC_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_RESOURCE_DESC_st>(),
        144usize,
        concat!("Size of: ", stringify!(CUDA_RESOURCE_DESC_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_RESOURCE_DESC_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_RESOURCE_DESC_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st>())).resType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st),
            "::",
            stringify!(resType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st>())).res as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st),
            "::",
            stringify!(res)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st>())).flags as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st),
            "::",
            stringify!(flags)
        )
    );
}
pub type CUDA_RESOURCE_DESC = CUDA_RESOURCE_DESC_st;
/// Texture descriptor
#[repr(C)]
pub struct CUDA_TEXTURE_DESC_st {
    ///< Address modes
    pub addressMode: [CUaddress_mode; 3usize],
    ///< Filter mode
    pub filterMode: CUfilter_mode,
    ///< Flags
    pub flags: ::std::os::raw::c_uint,
    ///< Maximum anisotropy ratio
    pub maxAnisotropy: ::std::os::raw::c_uint,
    ///< Mipmap filter mode
    pub mipmapFilterMode: CUfilter_mode,
    ///< Mipmap level bias
    pub mipmapLevelBias: f32,
    ///< Mipmap minimum level clamp
    pub minMipmapLevelClamp: f32,
    ///< Mipmap maximum level clamp
    pub maxMipmapLevelClamp: f32,
    ///< Border Color
    pub borderColor: [f32; 4usize],
    pub reserved: [::std::os::raw::c_int; 12usize],
}
#[test]
fn bindgen_test_layout_CUDA_TEXTURE_DESC_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_TEXTURE_DESC_st>(),
        104usize,
        concat!("Size of: ", stringify!(CUDA_TEXTURE_DESC_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_TEXTURE_DESC_st>(),
        4usize,
        concat!("Alignment of ", stringify!(CUDA_TEXTURE_DESC_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_TEXTURE_DESC_st>())).addressMode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_TEXTURE_DESC_st),
            "::",
            stringify!(addressMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_TEXTURE_DESC_st>())).filterMode as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_TEXTURE_DESC_st),
            "::",
            stringify!(filterMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_TEXTURE_DESC_st>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_TEXTURE_DESC_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_TEXTURE_DESC_st>())).maxAnisotropy as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_TEXTURE_DESC_st),
            "::",
            stringify!(maxAnisotropy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_TEXTURE_DESC_st>())).mipmapFilterMode as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_TEXTURE_DESC_st),
            "::",
            stringify!(mipmapFilterMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_TEXTURE_DESC_st>())).mipmapLevelBias as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_TEXTURE_DESC_st),
            "::",
            stringify!(mipmapLevelBias)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_TEXTURE_DESC_st>())).minMipmapLevelClamp as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_TEXTURE_DESC_st),
            "::",
            stringify!(minMipmapLevelClamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_TEXTURE_DESC_st>())).maxMipmapLevelClamp as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_TEXTURE_DESC_st),
            "::",
            stringify!(maxMipmapLevelClamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_TEXTURE_DESC_st>())).borderColor as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_TEXTURE_DESC_st),
            "::",
            stringify!(borderColor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_TEXTURE_DESC_st>())).reserved as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_TEXTURE_DESC_st),
            "::",
            stringify!(reserved)
        )
    );
}
pub type CUDA_TEXTURE_DESC = CUDA_TEXTURE_DESC_st;
#[repr(i32)]
/// Resource view format
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CUresourceViewFormat_enum {
    ///< No resource view format (use underlying resource format)
    CU_RES_VIEW_FORMAT_NONE = 0,
    ///< 1 channel unsigned 8-bit integers
    CU_RES_VIEW_FORMAT_UINT_1X8 = 1,
    ///< 2 channel unsigned 8-bit integers
    CU_RES_VIEW_FORMAT_UINT_2X8 = 2,
    ///< 4 channel unsigned 8-bit integers
    CU_RES_VIEW_FORMAT_UINT_4X8 = 3,
    ///< 1 channel signed 8-bit integers
    CU_RES_VIEW_FORMAT_SINT_1X8 = 4,
    ///< 2 channel signed 8-bit integers
    CU_RES_VIEW_FORMAT_SINT_2X8 = 5,
    ///< 4 channel signed 8-bit integers
    CU_RES_VIEW_FORMAT_SINT_4X8 = 6,
    ///< 1 channel unsigned 16-bit integers
    CU_RES_VIEW_FORMAT_UINT_1X16 = 7,
    ///< 2 channel unsigned 16-bit integers
    CU_RES_VIEW_FORMAT_UINT_2X16 = 8,
    ///< 4 channel unsigned 16-bit integers
    CU_RES_VIEW_FORMAT_UINT_4X16 = 9,
    ///< 1 channel signed 16-bit integers
    CU_RES_VIEW_FORMAT_SINT_1X16 = 10,
    ///< 2 channel signed 16-bit integers
    CU_RES_VIEW_FORMAT_SINT_2X16 = 11,
    ///< 4 channel signed 16-bit integers
    CU_RES_VIEW_FORMAT_SINT_4X16 = 12,
    ///< 1 channel unsigned 32-bit integers
    CU_RES_VIEW_FORMAT_UINT_1X32 = 13,
    ///< 2 channel unsigned 32-bit integers
    CU_RES_VIEW_FORMAT_UINT_2X32 = 14,
    ///< 4 channel unsigned 32-bit integers
    CU_RES_VIEW_FORMAT_UINT_4X32 = 15,
    ///< 1 channel signed 32-bit integers
    CU_RES_VIEW_FORMAT_SINT_1X32 = 16,
    ///< 2 channel signed 32-bit integers
    CU_RES_VIEW_FORMAT_SINT_2X32 = 17,
    ///< 4 channel signed 32-bit integers
    CU_RES_VIEW_FORMAT_SINT_4X32 = 18,
    ///< 1 channel 16-bit floating point
    CU_RES_VIEW_FORMAT_FLOAT_1X16 = 19,
    ///< 2 channel 16-bit floating point
    CU_RES_VIEW_FORMAT_FLOAT_2X16 = 20,
    ///< 4 channel 16-bit floating point
    CU_RES_VIEW_FORMAT_FLOAT_4X16 = 21,
    ///< 1 channel 32-bit floating point
    CU_RES_VIEW_FORMAT_FLOAT_1X32 = 22,
    ///< 2 channel 32-bit floating point
    CU_RES_VIEW_FORMAT_FLOAT_2X32 = 23,
    ///< 4 channel 32-bit floating point
    CU_RES_VIEW_FORMAT_FLOAT_4X32 = 24,
    ///< Block compressed 1
    CU_RES_VIEW_FORMAT_UNSIGNED_BC1 = 25,
    ///< Block compressed 2
    CU_RES_VIEW_FORMAT_UNSIGNED_BC2 = 26,
    ///< Block compressed 3
    CU_RES_VIEW_FORMAT_UNSIGNED_BC3 = 27,
    ///< Block compressed 4 unsigned
    CU_RES_VIEW_FORMAT_UNSIGNED_BC4 = 28,
    ///< Block compressed 4 signed
    CU_RES_VIEW_FORMAT_SIGNED_BC4 = 29,
    ///< Block compressed 5 unsigned
    CU_RES_VIEW_FORMAT_UNSIGNED_BC5 = 30,
    ///< Block compressed 5 signed
    CU_RES_VIEW_FORMAT_SIGNED_BC5 = 31,
    ///< Block compressed 6 unsigned half-float
    CU_RES_VIEW_FORMAT_UNSIGNED_BC6H = 32,
    ///< Block compressed 6 signed half-float
    CU_RES_VIEW_FORMAT_SIGNED_BC6H = 33,
    ///< Block compressed 7
    CU_RES_VIEW_FORMAT_UNSIGNED_BC7 = 34,
}
pub use self::CUresourceViewFormat_enum as CUresourceViewFormat;
/// Resource view descriptor
#[repr(C)]
pub struct CUDA_RESOURCE_VIEW_DESC_st {
    ///< Resource view format
    pub format: CUresourceViewFormat,
    ///< Width of the resource view
    pub width: usize,
    ///< Height of the resource view
    pub height: usize,
    ///< Depth of the resource view
    pub depth: usize,
    ///< First defined mipmap level
    pub firstMipmapLevel: ::std::os::raw::c_uint,
    ///< Last defined mipmap level
    pub lastMipmapLevel: ::std::os::raw::c_uint,
    ///< First layer index
    pub firstLayer: ::std::os::raw::c_uint,
    ///< Last layer index
    pub lastLayer: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[test]
fn bindgen_test_layout_CUDA_RESOURCE_VIEW_DESC_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_RESOURCE_VIEW_DESC_st>(),
        112usize,
        concat!("Size of: ", stringify!(CUDA_RESOURCE_VIEW_DESC_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_RESOURCE_VIEW_DESC_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_RESOURCE_VIEW_DESC_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_VIEW_DESC_st>())).format as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_VIEW_DESC_st>())).width as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_VIEW_DESC_st>())).height as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_VIEW_DESC_st>())).depth as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_VIEW_DESC_st>())).firstMipmapLevel as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(firstMipmapLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_VIEW_DESC_st>())).lastMipmapLevel as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(lastMipmapLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_VIEW_DESC_st>())).firstLayer as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(firstLayer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_VIEW_DESC_st>())).lastLayer as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(lastLayer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_VIEW_DESC_st>())).reserved as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(reserved)
        )
    );
}
pub type CUDA_RESOURCE_VIEW_DESC = CUDA_RESOURCE_VIEW_DESC_st;
/// GPU Direct v3 tokens
#[repr(C)]
pub struct CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st {
    pub p2pToken: ::std::os::raw::c_ulonglong,
    pub vaSpaceToken: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st>())).p2pToken as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st),
            "::",
            stringify!(p2pToken)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st>())).vaSpaceToken
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st),
            "::",
            stringify!(vaSpaceToken)
        )
    );
}
pub type CUDA_POINTER_ATTRIBUTE_P2P_TOKENS = CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st;
/// Kernel launch parameters
#[repr(C)]
pub struct CUDA_LAUNCH_PARAMS_st {
    ///< Kernel to launch
    pub function: CUfunction,
    ///< Width of grid in blocks
    pub gridDimX: ::std::os::raw::c_uint,
    ///< Height of grid in blocks
    pub gridDimY: ::std::os::raw::c_uint,
    ///< Depth of grid in blocks
    pub gridDimZ: ::std::os::raw::c_uint,
    ///< X dimension of each thread block
    pub blockDimX: ::std::os::raw::c_uint,
    ///< Y dimension of each thread block
    pub blockDimY: ::std::os::raw::c_uint,
    ///< Z dimension of each thread block
    pub blockDimZ: ::std::os::raw::c_uint,
    ///< Dynamic shared-memory size per thread block in bytes
    pub sharedMemBytes: ::std::os::raw::c_uint,
    ///< Stream identifier
    pub hStream: CUstream,
    ///< Array of pointers to kernel parameters
    pub kernelParams: *mut *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_CUDA_LAUNCH_PARAMS_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_LAUNCH_PARAMS_st>(),
        56usize,
        concat!("Size of: ", stringify!(CUDA_LAUNCH_PARAMS_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_LAUNCH_PARAMS_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_LAUNCH_PARAMS_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_LAUNCH_PARAMS_st>())).function as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_LAUNCH_PARAMS_st),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_LAUNCH_PARAMS_st>())).gridDimX as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_LAUNCH_PARAMS_st),
            "::",
            stringify!(gridDimX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_LAUNCH_PARAMS_st>())).gridDimY as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_LAUNCH_PARAMS_st),
            "::",
            stringify!(gridDimY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_LAUNCH_PARAMS_st>())).gridDimZ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_LAUNCH_PARAMS_st),
            "::",
            stringify!(gridDimZ)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_LAUNCH_PARAMS_st>())).blockDimX as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_LAUNCH_PARAMS_st),
            "::",
            stringify!(blockDimX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_LAUNCH_PARAMS_st>())).blockDimY as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_LAUNCH_PARAMS_st),
            "::",
            stringify!(blockDimY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_LAUNCH_PARAMS_st>())).blockDimZ as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_LAUNCH_PARAMS_st),
            "::",
            stringify!(blockDimZ)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_LAUNCH_PARAMS_st>())).sharedMemBytes as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_LAUNCH_PARAMS_st),
            "::",
            stringify!(sharedMemBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_LAUNCH_PARAMS_st>())).hStream as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_LAUNCH_PARAMS_st),
            "::",
            stringify!(hStream)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_LAUNCH_PARAMS_st>())).kernelParams as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_LAUNCH_PARAMS_st),
            "::",
            stringify!(kernelParams)
        )
    );
}
pub type CUDA_LAUNCH_PARAMS = CUDA_LAUNCH_PARAMS_st;
#[repr(i32)]
/// External memory handle types
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CUexternalMemoryHandleType_enum {
    /// Handle is an opaque file descriptor
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD = 1,
    /// Handle is an opaque shared NT handle
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32 = 2,
    /// Handle is an opaque, globally shared handle
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT = 3,
    /// Handle is a D3D12 heap object
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP = 4,
    /// Handle is a D3D12 committed resource
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE = 5,
}
pub use self::CUexternalMemoryHandleType_enum as CUexternalMemoryHandleType;
/// External memory handle descriptor
#[repr(C)]
pub struct CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st {
    /// Type of the handle
    pub type_: CUexternalMemoryHandleType,
    pub handle: CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1,
    /// Size of the memory allocation
    pub size: ::std::os::raw::c_ulonglong,
    /// Flags must either be zero or ::CUDA_EXTERNAL_MEMORY_DEDICATED
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[repr(C)]
pub union CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1 {
    /// File descriptor referencing the memory object. Valid
    /// when type is
    /// ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD
    pub fd: ::std::os::raw::c_int,
    pub win32: CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u64; 2usize],
}
/// Win32 handle referencing the semaphore object. Valid when
/// type is one of the following:
/// - ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32
/// - ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT
/// - ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP
/// - ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE
/// Exactly one of 'handle' and 'name' must be non-NULL. If
/// type is
/// ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT
/// then 'name' must be NULL.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1 {
    /// Valid NT handle. Must be NULL if 'name' is non-NULL
    pub handle: *mut ::std::os::raw::c_void,
    /// Name of a valid memory object.
    /// Must be NULL if 'handle' is non-NULL.
    pub name: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1>(
            )))
            .handle as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1>(
            )))
            .name as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(name)
        )
    );
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1>())).fd
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1>())).win32
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(win32)
        )
    );
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st>(),
        104usize,
        concat!("Size of: ", stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st>())).type_ as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st>())).handle as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st>())).size as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st>())).flags as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st>())).reserved as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st),
            "::",
            stringify!(reserved)
        )
    );
}
pub type CUDA_EXTERNAL_MEMORY_HANDLE_DESC = CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st;
/// External memory buffer descriptor
#[repr(C)]
pub struct CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st {
    /// Offset into the memory object where the buffer's base is
    pub offset: ::std::os::raw::c_ulonglong,
    /// Size of the buffer
    pub size: ::std::os::raw::c_ulonglong,
    /// Flags reserved for future use. Must be zero.
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st>(),
        88usize,
        concat!("Size of: ", stringify!(CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st>())).offset as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st>())).flags as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st>())).reserved as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st),
            "::",
            stringify!(reserved)
        )
    );
}
pub type CUDA_EXTERNAL_MEMORY_BUFFER_DESC = CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st;
/// External memory mipmap descriptor
#[repr(C)]
pub struct CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st {
    /// Offset into the memory object where the base level of the
    /// mipmap chain is.
    pub offset: ::std::os::raw::c_ulonglong,
    /// Format, dimension and type of base level of the mipmap chain
    pub arrayDesc: CUDA_ARRAY3D_DESCRIPTOR,
    /// Total number of levels in the mipmap chain
    pub numLevels: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st>(),
        120usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st>())).offset
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st>())).arrayDesc
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st),
            "::",
            stringify!(arrayDesc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st>())).numLevels
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st),
            "::",
            stringify!(numLevels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st>())).reserved
                as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st),
            "::",
            stringify!(reserved)
        )
    );
}
pub type CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC = CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st;
#[repr(i32)]
/// External semaphore handle types
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CUexternalSemaphoreHandleType_enum {
    /// Handle is an opaque file descriptor
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD = 1,
    /// Handle is an opaque shared NT handle
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32 = 2,
    /// Handle is an opaque, globally shared handle
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT = 3,
    /// Handle is a shared NT handle referencing a D3D12 fence object
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE = 4,
}
pub use self::CUexternalSemaphoreHandleType_enum as CUexternalSemaphoreHandleType;
/// External semaphore handle descriptor
#[repr(C)]
pub struct CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st {
    /// Type of the handle
    pub type_: CUexternalSemaphoreHandleType,
    pub handle: CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1,
    /// Flags reserved for the future. Must be zero.
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[repr(C)]
pub union CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1 {
    /// File descriptor referencing the semaphore object. Valid
    /// when type is
    /// ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD
    pub fd: ::std::os::raw::c_int,
    pub win32: CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u64; 2usize],
}
/// Win32 handle referencing the semaphore object. Valid when
/// type is one of the following:
/// - ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32
/// - ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT
/// - ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE
/// Exactly one of 'handle' and 'name' must be non-NULL. If
/// type is
/// ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT
/// then 'name' must be NULL.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1 {
    /// Valid NT handle. Must be NULL if 'name' is non-NULL
    pub handle: *mut ::std::os::raw::c_void,
    /// Name of a valid synchronization primitive.
    /// Must be NULL if 'handle' is non-NULL.
    pub name: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1,
            >()))
            .handle as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1,
            >()))
            .name as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(name)
        )
    );
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1>())).fd
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1>())).win32
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(win32)
        )
    );
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st>(),
        96usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st>())).type_ as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st>())).handle as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st>())).flags as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st>())).reserved as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st),
            "::",
            stringify!(reserved)
        )
    );
}
pub type CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC = CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st;
/// External semaphore signal parameters
#[repr(C)]
pub struct CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st {
    pub params: CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1,
    /// Flags reserved for the future. Must be zero.
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[repr(C)]
pub struct CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1 {
    pub fence: CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
/// Parameters for fence objects
#[repr(C)]
pub struct CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1 {
    /// Value of fence to be signaled
    pub value: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1>(
        ),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1,
            >()))
            .value as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(value)
        )
    );
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1>())).fence
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1),
            "::",
            stringify!(fence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1>()))
                .reserved as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st>(),
        144usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st>())).params as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st),
            "::",
            stringify!(params)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st>())).flags as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st>())).reserved
                as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st),
            "::",
            stringify!(reserved)
        )
    );
}
pub type CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS = CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st;
/// External semaphore wait parameters
#[repr(C)]
pub struct CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st {
    pub params: CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1,
    /// Flags reserved for the future. Must be zero.
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[repr(C)]
pub struct CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1 {
    pub fence: CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
/// Parameters for fence objects
#[repr(C)]
pub struct CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1 {
    /// Value of fence to be waited on
    pub value: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1,
            >()))
            .value as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(value)
        )
    );
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1>())).fence
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1),
            "::",
            stringify!(fence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1>()))
                .reserved as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st>(),
        144usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st>())).params as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st),
            "::",
            stringify!(params)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st>())).flags as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st>())).reserved as *const _
                as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st),
            "::",
            stringify!(reserved)
        )
    );
}
pub type CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS = CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st;
